/* automatically generated by rust-bindgen 0.59.2 */

pub const CK_TRUE: u8 = 1;
pub const CK_FALSE: u8 = 0;
pub const CK_EFFECTIVELY_INFINITE: ::std::os::raw::c_ulong = 0;
pub const CK_INVALID_HANDLE: ::std::os::raw::c_ulong = 0;
pub const CKN_SURRENDER: ::std::os::raw::c_ulong = 0;
pub const CKN_OTP_CHANGED: ::std::os::raw::c_ulong = 1;
pub const CKF_TOKEN_PRESENT: ::std::os::raw::c_ulong = 1;
pub const CKF_REMOVABLE_DEVICE: ::std::os::raw::c_ulong = 2;
pub const CKF_HW_SLOT: ::std::os::raw::c_ulong = 4;
pub const CKF_RNG: ::std::os::raw::c_ulong = 1;
pub const CKF_WRITE_PROTECTED: ::std::os::raw::c_ulong = 2;
pub const CKF_LOGIN_REQUIRED: ::std::os::raw::c_ulong = 4;
pub const CKF_USER_PIN_INITIALIZED: ::std::os::raw::c_ulong = 8;
pub const CKF_RESTORE_KEY_NOT_NEEDED: ::std::os::raw::c_ulong = 32;
pub const CKF_CLOCK_ON_TOKEN: ::std::os::raw::c_ulong = 64;
pub const CKF_PROTECTED_AUTHENTICATION_PATH: ::std::os::raw::c_ulong = 256;
pub const CKF_DUAL_CRYPTO_OPERATIONS: ::std::os::raw::c_ulong = 512;
pub const CKF_TOKEN_INITIALIZED: ::std::os::raw::c_ulong = 1024;
pub const CKF_SECONDARY_AUTHENTICATION: ::std::os::raw::c_ulong = 2048;
pub const CKF_USER_PIN_COUNT_LOW: ::std::os::raw::c_ulong = 65536;
pub const CKF_USER_PIN_FINAL_TRY: ::std::os::raw::c_ulong = 131072;
pub const CKF_USER_PIN_LOCKED: ::std::os::raw::c_ulong = 262144;
pub const CKF_USER_PIN_TO_BE_CHANGED: ::std::os::raw::c_ulong = 524288;
pub const CKF_SO_PIN_COUNT_LOW: ::std::os::raw::c_ulong = 1048576;
pub const CKF_SO_PIN_FINAL_TRY: ::std::os::raw::c_ulong = 2097152;
pub const CKF_SO_PIN_LOCKED: ::std::os::raw::c_ulong = 4194304;
pub const CKF_SO_PIN_TO_BE_CHANGED: ::std::os::raw::c_ulong = 8388608;
pub const CKF_ERROR_STATE: ::std::os::raw::c_ulong = 16777216;
pub const CKU_SO: ::std::os::raw::c_ulong = 0;
pub const CKU_USER: ::std::os::raw::c_ulong = 1;
pub const CKU_CONTEXT_SPECIFIC: ::std::os::raw::c_ulong = 2;
pub const CKS_RO_PUBLIC_SESSION: ::std::os::raw::c_ulong = 0;
pub const CKS_RO_USER_FUNCTIONS: ::std::os::raw::c_ulong = 1;
pub const CKS_RW_PUBLIC_SESSION: ::std::os::raw::c_ulong = 2;
pub const CKS_RW_USER_FUNCTIONS: ::std::os::raw::c_ulong = 3;
pub const CKS_RW_SO_FUNCTIONS: ::std::os::raw::c_ulong = 4;
pub const CKF_RW_SESSION: ::std::os::raw::c_ulong = 2;
pub const CKF_SERIAL_SESSION: ::std::os::raw::c_ulong = 4;
pub const CKO_DATA: ::std::os::raw::c_ulong = 0;
pub const CKO_CERTIFICATE: ::std::os::raw::c_ulong = 1;
pub const CKO_PUBLIC_KEY: ::std::os::raw::c_ulong = 2;
pub const CKO_PRIVATE_KEY: ::std::os::raw::c_ulong = 3;
pub const CKO_SECRET_KEY: ::std::os::raw::c_ulong = 4;
pub const CKO_HW_FEATURE: ::std::os::raw::c_ulong = 5;
pub const CKO_DOMAIN_PARAMETERS: ::std::os::raw::c_ulong = 6;
pub const CKO_MECHANISM: ::std::os::raw::c_ulong = 7;
pub const CKO_OTP_KEY: ::std::os::raw::c_ulong = 8;
pub const CKO_VENDOR_DEFINED: ::std::os::raw::c_ulong = 2147483648;
pub const CKH_MONOTONIC_COUNTER: ::std::os::raw::c_ulong = 1;
pub const CKH_CLOCK: ::std::os::raw::c_ulong = 2;
pub const CKH_USER_INTERFACE: ::std::os::raw::c_ulong = 3;
pub const CKH_VENDOR_DEFINED: ::std::os::raw::c_ulong = 2147483648;
pub const CKK_RSA: ::std::os::raw::c_ulong = 0;
pub const CKK_DSA: ::std::os::raw::c_ulong = 1;
pub const CKK_DH: ::std::os::raw::c_ulong = 2;
pub const CKK_EC: ::std::os::raw::c_ulong = 3;
pub const CKK_X9_42_DH: ::std::os::raw::c_ulong = 4;
pub const CKK_KEA: ::std::os::raw::c_ulong = 5;
pub const CKK_GENERIC_SECRET: ::std::os::raw::c_ulong = 16;
pub const CKK_RC2: ::std::os::raw::c_ulong = 17;
pub const CKK_RC4: ::std::os::raw::c_ulong = 18;
pub const CKK_DES: ::std::os::raw::c_ulong = 19;
pub const CKK_DES2: ::std::os::raw::c_ulong = 20;
pub const CKK_DES3: ::std::os::raw::c_ulong = 21;
pub const CKK_CAST: ::std::os::raw::c_ulong = 22;
pub const CKK_CAST3: ::std::os::raw::c_ulong = 23;
pub const CKK_CAST128: ::std::os::raw::c_ulong = 24;
pub const CKK_RC5: ::std::os::raw::c_ulong = 25;
pub const CKK_IDEA: ::std::os::raw::c_ulong = 26;
pub const CKK_SKIPJACK: ::std::os::raw::c_ulong = 27;
pub const CKK_BATON: ::std::os::raw::c_ulong = 28;
pub const CKK_JUNIPER: ::std::os::raw::c_ulong = 29;
pub const CKK_CDMF: ::std::os::raw::c_ulong = 30;
pub const CKK_AES: ::std::os::raw::c_ulong = 31;
pub const CKK_BLOWFISH: ::std::os::raw::c_ulong = 32;
pub const CKK_TWOFISH: ::std::os::raw::c_ulong = 33;
pub const CKK_SECURID: ::std::os::raw::c_ulong = 34;
pub const CKK_HOTP: ::std::os::raw::c_ulong = 35;
pub const CKK_ACTI: ::std::os::raw::c_ulong = 36;
pub const CKK_CAMELLIA: ::std::os::raw::c_ulong = 37;
pub const CKK_ARIA: ::std::os::raw::c_ulong = 38;
pub const CKK_MD5_HMAC: ::std::os::raw::c_ulong = 39;
pub const CKK_SHA_1_HMAC: ::std::os::raw::c_ulong = 40;
pub const CKK_RIPEMD128_HMAC: ::std::os::raw::c_ulong = 41;
pub const CKK_RIPEMD160_HMAC: ::std::os::raw::c_ulong = 42;
pub const CKK_SHA256_HMAC: ::std::os::raw::c_ulong = 43;
pub const CKK_SHA384_HMAC: ::std::os::raw::c_ulong = 44;
pub const CKK_SHA512_HMAC: ::std::os::raw::c_ulong = 45;
pub const CKK_SHA224_HMAC: ::std::os::raw::c_ulong = 46;
pub const CKK_SEED: ::std::os::raw::c_ulong = 47;
pub const CKK_GOSTR3410: ::std::os::raw::c_ulong = 48;
pub const CKK_GOSTR3411: ::std::os::raw::c_ulong = 49;
pub const CKK_GOST28147: ::std::os::raw::c_ulong = 50;
pub const CKK_VENDOR_DEFINED: ::std::os::raw::c_ulong = 2147483648;
pub const CK_CERTIFICATE_CATEGORY_UNSPECIFIED: ::std::os::raw::c_ulong = 0;
pub const CK_CERTIFICATE_CATEGORY_TOKEN_USER: ::std::os::raw::c_ulong = 1;
pub const CK_CERTIFICATE_CATEGORY_AUTHORITY: ::std::os::raw::c_ulong = 2;
pub const CK_CERTIFICATE_CATEGORY_OTHER_ENTITY: ::std::os::raw::c_ulong = 3;
pub const CK_SECURITY_DOMAIN_UNSPECIFIED: ::std::os::raw::c_ulong = 0;
pub const CK_SECURITY_DOMAIN_MANUFACTURER: ::std::os::raw::c_ulong = 1;
pub const CK_SECURITY_DOMAIN_OPERATOR: ::std::os::raw::c_ulong = 2;
pub const CK_SECURITY_DOMAIN_THIRD_PARTY: ::std::os::raw::c_ulong = 3;
pub const CKC_X_509: ::std::os::raw::c_ulong = 0;
pub const CKC_X_509_ATTR_CERT: ::std::os::raw::c_ulong = 1;
pub const CKC_WTLS: ::std::os::raw::c_ulong = 2;
pub const CKC_VENDOR_DEFINED: ::std::os::raw::c_ulong = 2147483648;
pub const CKF_ARRAY_ATTRIBUTE: ::std::os::raw::c_ulong = 1073741824;
pub const CK_OTP_FORMAT_DECIMAL: ::std::os::raw::c_ulong = 0;
pub const CK_OTP_FORMAT_HEXADECIMAL: ::std::os::raw::c_ulong = 1;
pub const CK_OTP_FORMAT_ALPHANUMERIC: ::std::os::raw::c_ulong = 2;
pub const CK_OTP_FORMAT_BINARY: ::std::os::raw::c_ulong = 3;
pub const CK_OTP_PARAM_IGNORED: ::std::os::raw::c_ulong = 0;
pub const CK_OTP_PARAM_OPTIONAL: ::std::os::raw::c_ulong = 1;
pub const CK_OTP_PARAM_MANDATORY: ::std::os::raw::c_ulong = 2;
pub const CKA_CLASS: ::std::os::raw::c_ulong = 0;
pub const CKA_TOKEN: ::std::os::raw::c_ulong = 1;
pub const CKA_PRIVATE: ::std::os::raw::c_ulong = 2;
pub const CKA_LABEL: ::std::os::raw::c_ulong = 3;
pub const CKA_APPLICATION: ::std::os::raw::c_ulong = 16;
pub const CKA_VALUE: ::std::os::raw::c_ulong = 17;
pub const CKA_OBJECT_ID: ::std::os::raw::c_ulong = 18;
pub const CKA_CERTIFICATE_TYPE: ::std::os::raw::c_ulong = 128;
pub const CKA_ISSUER: ::std::os::raw::c_ulong = 129;
pub const CKA_SERIAL_NUMBER: ::std::os::raw::c_ulong = 130;
pub const CKA_AC_ISSUER: ::std::os::raw::c_ulong = 131;
pub const CKA_OWNER: ::std::os::raw::c_ulong = 132;
pub const CKA_ATTR_TYPES: ::std::os::raw::c_ulong = 133;
pub const CKA_TRUSTED: ::std::os::raw::c_ulong = 134;
pub const CKA_CERTIFICATE_CATEGORY: ::std::os::raw::c_ulong = 135;
pub const CKA_JAVA_MIDP_SECURITY_DOMAIN: ::std::os::raw::c_ulong = 136;
pub const CKA_URL: ::std::os::raw::c_ulong = 137;
pub const CKA_HASH_OF_SUBJECT_PUBLIC_KEY: ::std::os::raw::c_ulong = 138;
pub const CKA_HASH_OF_ISSUER_PUBLIC_KEY: ::std::os::raw::c_ulong = 139;
pub const CKA_NAME_HASH_ALGORITHM: ::std::os::raw::c_ulong = 140;
pub const CKA_CHECK_VALUE: ::std::os::raw::c_ulong = 144;
pub const CKA_KEY_TYPE: ::std::os::raw::c_ulong = 256;
pub const CKA_SUBJECT: ::std::os::raw::c_ulong = 257;
pub const CKA_ID: ::std::os::raw::c_ulong = 258;
pub const CKA_SENSITIVE: ::std::os::raw::c_ulong = 259;
pub const CKA_ENCRYPT: ::std::os::raw::c_ulong = 260;
pub const CKA_DECRYPT: ::std::os::raw::c_ulong = 261;
pub const CKA_WRAP: ::std::os::raw::c_ulong = 262;
pub const CKA_UNWRAP: ::std::os::raw::c_ulong = 263;
pub const CKA_SIGN: ::std::os::raw::c_ulong = 264;
pub const CKA_SIGN_RECOVER: ::std::os::raw::c_ulong = 265;
pub const CKA_VERIFY: ::std::os::raw::c_ulong = 266;
pub const CKA_VERIFY_RECOVER: ::std::os::raw::c_ulong = 267;
pub const CKA_DERIVE: ::std::os::raw::c_ulong = 268;
pub const CKA_START_DATE: ::std::os::raw::c_ulong = 272;
pub const CKA_END_DATE: ::std::os::raw::c_ulong = 273;
pub const CKA_MODULUS: ::std::os::raw::c_ulong = 288;
pub const CKA_MODULUS_BITS: ::std::os::raw::c_ulong = 289;
pub const CKA_PUBLIC_EXPONENT: ::std::os::raw::c_ulong = 290;
pub const CKA_PRIVATE_EXPONENT: ::std::os::raw::c_ulong = 291;
pub const CKA_PRIME_1: ::std::os::raw::c_ulong = 292;
pub const CKA_PRIME_2: ::std::os::raw::c_ulong = 293;
pub const CKA_EXPONENT_1: ::std::os::raw::c_ulong = 294;
pub const CKA_EXPONENT_2: ::std::os::raw::c_ulong = 295;
pub const CKA_COEFFICIENT: ::std::os::raw::c_ulong = 296;
pub const CKA_PUBLIC_KEY_INFO: ::std::os::raw::c_ulong = 297;
pub const CKA_PRIME: ::std::os::raw::c_ulong = 304;
pub const CKA_SUBPRIME: ::std::os::raw::c_ulong = 305;
pub const CKA_BASE: ::std::os::raw::c_ulong = 306;
pub const CKA_PRIME_BITS: ::std::os::raw::c_ulong = 307;
pub const CKA_SUBPRIME_BITS: ::std::os::raw::c_ulong = 308;
pub const CKA_VALUE_BITS: ::std::os::raw::c_ulong = 352;
pub const CKA_VALUE_LEN: ::std::os::raw::c_ulong = 353;
pub const CKA_EXTRACTABLE: ::std::os::raw::c_ulong = 354;
pub const CKA_LOCAL: ::std::os::raw::c_ulong = 355;
pub const CKA_NEVER_EXTRACTABLE: ::std::os::raw::c_ulong = 356;
pub const CKA_ALWAYS_SENSITIVE: ::std::os::raw::c_ulong = 357;
pub const CKA_KEY_GEN_MECHANISM: ::std::os::raw::c_ulong = 358;
pub const CKA_MODIFIABLE: ::std::os::raw::c_ulong = 368;
pub const CKA_COPYABLE: ::std::os::raw::c_ulong = 369;
pub const CKA_DESTROYABLE: ::std::os::raw::c_ulong = 370;
pub const CKA_EC_PARAMS: ::std::os::raw::c_ulong = 384;
pub const CKA_EC_POINT: ::std::os::raw::c_ulong = 385;
pub const CKA_ALWAYS_AUTHENTICATE: ::std::os::raw::c_ulong = 514;
pub const CKA_WRAP_WITH_TRUSTED: ::std::os::raw::c_ulong = 528;
pub const CKA_WRAP_TEMPLATE: ::std::os::raw::c_ulong = 1073742353;
pub const CKA_UNWRAP_TEMPLATE: ::std::os::raw::c_ulong = 1073742354;
pub const CKA_DERIVE_TEMPLATE: ::std::os::raw::c_ulong = 1073742355;
pub const CKA_OTP_FORMAT: ::std::os::raw::c_ulong = 544;
pub const CKA_OTP_LENGTH: ::std::os::raw::c_ulong = 545;
pub const CKA_OTP_TIME_INTERVAL: ::std::os::raw::c_ulong = 546;
pub const CKA_OTP_USER_FRIENDLY_MODE: ::std::os::raw::c_ulong = 547;
pub const CKA_OTP_CHALLENGE_REQUIREMENT: ::std::os::raw::c_ulong = 548;
pub const CKA_OTP_TIME_REQUIREMENT: ::std::os::raw::c_ulong = 549;
pub const CKA_OTP_COUNTER_REQUIREMENT: ::std::os::raw::c_ulong = 550;
pub const CKA_OTP_PIN_REQUIREMENT: ::std::os::raw::c_ulong = 551;
pub const CKA_OTP_COUNTER: ::std::os::raw::c_ulong = 558;
pub const CKA_OTP_TIME: ::std::os::raw::c_ulong = 559;
pub const CKA_OTP_USER_IDENTIFIER: ::std::os::raw::c_ulong = 554;
pub const CKA_OTP_SERVICE_IDENTIFIER: ::std::os::raw::c_ulong = 555;
pub const CKA_OTP_SERVICE_LOGO: ::std::os::raw::c_ulong = 556;
pub const CKA_OTP_SERVICE_LOGO_TYPE: ::std::os::raw::c_ulong = 557;
pub const CKA_GOSTR3410_PARAMS: ::std::os::raw::c_ulong = 592;
pub const CKA_GOSTR3411_PARAMS: ::std::os::raw::c_ulong = 593;
pub const CKA_GOST28147_PARAMS: ::std::os::raw::c_ulong = 594;
pub const CKA_HW_FEATURE_TYPE: ::std::os::raw::c_ulong = 768;
pub const CKA_RESET_ON_INIT: ::std::os::raw::c_ulong = 769;
pub const CKA_HAS_RESET: ::std::os::raw::c_ulong = 770;
pub const CKA_PIXEL_X: ::std::os::raw::c_ulong = 1024;
pub const CKA_PIXEL_Y: ::std::os::raw::c_ulong = 1025;
pub const CKA_RESOLUTION: ::std::os::raw::c_ulong = 1026;
pub const CKA_CHAR_ROWS: ::std::os::raw::c_ulong = 1027;
pub const CKA_CHAR_COLUMNS: ::std::os::raw::c_ulong = 1028;
pub const CKA_COLOR: ::std::os::raw::c_ulong = 1029;
pub const CKA_BITS_PER_PIXEL: ::std::os::raw::c_ulong = 1030;
pub const CKA_CHAR_SETS: ::std::os::raw::c_ulong = 1152;
pub const CKA_ENCODING_METHODS: ::std::os::raw::c_ulong = 1153;
pub const CKA_MIME_TYPES: ::std::os::raw::c_ulong = 1154;
pub const CKA_MECHANISM_TYPE: ::std::os::raw::c_ulong = 1280;
pub const CKA_REQUIRED_CMS_ATTRIBUTES: ::std::os::raw::c_ulong = 1281;
pub const CKA_DEFAULT_CMS_ATTRIBUTES: ::std::os::raw::c_ulong = 1282;
pub const CKA_SUPPORTED_CMS_ATTRIBUTES: ::std::os::raw::c_ulong = 1283;
pub const CKA_ALLOWED_MECHANISMS: ::std::os::raw::c_ulong = 1073743360;
pub const CKA_VENDOR_DEFINED: ::std::os::raw::c_ulong = 2147483648;
pub const CKM_RSA_PKCS_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 0;
pub const CKM_RSA_PKCS: ::std::os::raw::c_ulong = 1;
pub const CKM_RSA_9796: ::std::os::raw::c_ulong = 2;
pub const CKM_RSA_X_509: ::std::os::raw::c_ulong = 3;
pub const CKM_MD2_RSA_PKCS: ::std::os::raw::c_ulong = 4;
pub const CKM_MD5_RSA_PKCS: ::std::os::raw::c_ulong = 5;
pub const CKM_SHA1_RSA_PKCS: ::std::os::raw::c_ulong = 6;
pub const CKM_RIPEMD128_RSA_PKCS: ::std::os::raw::c_ulong = 7;
pub const CKM_RIPEMD160_RSA_PKCS: ::std::os::raw::c_ulong = 8;
pub const CKM_RSA_PKCS_OAEP: ::std::os::raw::c_ulong = 9;
pub const CKM_RSA_X9_31_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 10;
pub const CKM_RSA_X9_31: ::std::os::raw::c_ulong = 11;
pub const CKM_SHA1_RSA_X9_31: ::std::os::raw::c_ulong = 12;
pub const CKM_RSA_PKCS_PSS: ::std::os::raw::c_ulong = 13;
pub const CKM_SHA1_RSA_PKCS_PSS: ::std::os::raw::c_ulong = 14;
pub const CKM_DSA_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 16;
pub const CKM_DSA: ::std::os::raw::c_ulong = 17;
pub const CKM_DSA_SHA1: ::std::os::raw::c_ulong = 18;
pub const CKM_DSA_SHA224: ::std::os::raw::c_ulong = 19;
pub const CKM_DSA_SHA256: ::std::os::raw::c_ulong = 20;
pub const CKM_DSA_SHA384: ::std::os::raw::c_ulong = 21;
pub const CKM_DSA_SHA512: ::std::os::raw::c_ulong = 22;
pub const CKM_DH_PKCS_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 32;
pub const CKM_DH_PKCS_DERIVE: ::std::os::raw::c_ulong = 33;
pub const CKM_X9_42_DH_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 48;
pub const CKM_X9_42_DH_DERIVE: ::std::os::raw::c_ulong = 49;
pub const CKM_X9_42_DH_HYBRID_DERIVE: ::std::os::raw::c_ulong = 50;
pub const CKM_X9_42_MQV_DERIVE: ::std::os::raw::c_ulong = 51;
pub const CKM_SHA256_RSA_PKCS: ::std::os::raw::c_ulong = 64;
pub const CKM_SHA384_RSA_PKCS: ::std::os::raw::c_ulong = 65;
pub const CKM_SHA512_RSA_PKCS: ::std::os::raw::c_ulong = 66;
pub const CKM_SHA256_RSA_PKCS_PSS: ::std::os::raw::c_ulong = 67;
pub const CKM_SHA384_RSA_PKCS_PSS: ::std::os::raw::c_ulong = 68;
pub const CKM_SHA512_RSA_PKCS_PSS: ::std::os::raw::c_ulong = 69;
pub const CKM_SHA224_RSA_PKCS: ::std::os::raw::c_ulong = 70;
pub const CKM_SHA224_RSA_PKCS_PSS: ::std::os::raw::c_ulong = 71;
pub const CKM_SHA512_224: ::std::os::raw::c_ulong = 72;
pub const CKM_SHA512_224_HMAC: ::std::os::raw::c_ulong = 73;
pub const CKM_SHA512_224_HMAC_GENERAL: ::std::os::raw::c_ulong = 74;
pub const CKM_SHA512_224_KEY_DERIVATION: ::std::os::raw::c_ulong = 75;
pub const CKM_SHA512_256: ::std::os::raw::c_ulong = 76;
pub const CKM_SHA512_256_HMAC: ::std::os::raw::c_ulong = 77;
pub const CKM_SHA512_256_HMAC_GENERAL: ::std::os::raw::c_ulong = 78;
pub const CKM_SHA512_256_KEY_DERIVATION: ::std::os::raw::c_ulong = 79;
pub const CKM_SHA512_T: ::std::os::raw::c_ulong = 80;
pub const CKM_SHA512_T_HMAC: ::std::os::raw::c_ulong = 81;
pub const CKM_SHA512_T_HMAC_GENERAL: ::std::os::raw::c_ulong = 82;
pub const CKM_SHA512_T_KEY_DERIVATION: ::std::os::raw::c_ulong = 83;
pub const CKM_RC2_KEY_GEN: ::std::os::raw::c_ulong = 256;
pub const CKM_RC2_ECB: ::std::os::raw::c_ulong = 257;
pub const CKM_RC2_CBC: ::std::os::raw::c_ulong = 258;
pub const CKM_RC2_MAC: ::std::os::raw::c_ulong = 259;
pub const CKM_RC2_MAC_GENERAL: ::std::os::raw::c_ulong = 260;
pub const CKM_RC2_CBC_PAD: ::std::os::raw::c_ulong = 261;
pub const CKM_RC4_KEY_GEN: ::std::os::raw::c_ulong = 272;
pub const CKM_RC4: ::std::os::raw::c_ulong = 273;
pub const CKM_DES_KEY_GEN: ::std::os::raw::c_ulong = 288;
pub const CKM_DES_ECB: ::std::os::raw::c_ulong = 289;
pub const CKM_DES_CBC: ::std::os::raw::c_ulong = 290;
pub const CKM_DES_MAC: ::std::os::raw::c_ulong = 291;
pub const CKM_DES_MAC_GENERAL: ::std::os::raw::c_ulong = 292;
pub const CKM_DES_CBC_PAD: ::std::os::raw::c_ulong = 293;
pub const CKM_DES2_KEY_GEN: ::std::os::raw::c_ulong = 304;
pub const CKM_DES3_KEY_GEN: ::std::os::raw::c_ulong = 305;
pub const CKM_DES3_ECB: ::std::os::raw::c_ulong = 306;
pub const CKM_DES3_CBC: ::std::os::raw::c_ulong = 307;
pub const CKM_DES3_MAC: ::std::os::raw::c_ulong = 308;
pub const CKM_DES3_MAC_GENERAL: ::std::os::raw::c_ulong = 309;
pub const CKM_DES3_CBC_PAD: ::std::os::raw::c_ulong = 310;
pub const CKM_DES3_CMAC_GENERAL: ::std::os::raw::c_ulong = 311;
pub const CKM_DES3_CMAC: ::std::os::raw::c_ulong = 312;
pub const CKM_CDMF_KEY_GEN: ::std::os::raw::c_ulong = 320;
pub const CKM_CDMF_ECB: ::std::os::raw::c_ulong = 321;
pub const CKM_CDMF_CBC: ::std::os::raw::c_ulong = 322;
pub const CKM_CDMF_MAC: ::std::os::raw::c_ulong = 323;
pub const CKM_CDMF_MAC_GENERAL: ::std::os::raw::c_ulong = 324;
pub const CKM_CDMF_CBC_PAD: ::std::os::raw::c_ulong = 325;
pub const CKM_DES_OFB64: ::std::os::raw::c_ulong = 336;
pub const CKM_DES_OFB8: ::std::os::raw::c_ulong = 337;
pub const CKM_DES_CFB64: ::std::os::raw::c_ulong = 338;
pub const CKM_DES_CFB8: ::std::os::raw::c_ulong = 339;
pub const CKM_MD2: ::std::os::raw::c_ulong = 512;
pub const CKM_MD2_HMAC: ::std::os::raw::c_ulong = 513;
pub const CKM_MD2_HMAC_GENERAL: ::std::os::raw::c_ulong = 514;
pub const CKM_MD5: ::std::os::raw::c_ulong = 528;
pub const CKM_MD5_HMAC: ::std::os::raw::c_ulong = 529;
pub const CKM_MD5_HMAC_GENERAL: ::std::os::raw::c_ulong = 530;
pub const CKM_SHA_1: ::std::os::raw::c_ulong = 544;
pub const CKM_SHA_1_HMAC: ::std::os::raw::c_ulong = 545;
pub const CKM_SHA_1_HMAC_GENERAL: ::std::os::raw::c_ulong = 546;
pub const CKM_RIPEMD128: ::std::os::raw::c_ulong = 560;
pub const CKM_RIPEMD128_HMAC: ::std::os::raw::c_ulong = 561;
pub const CKM_RIPEMD128_HMAC_GENERAL: ::std::os::raw::c_ulong = 562;
pub const CKM_RIPEMD160: ::std::os::raw::c_ulong = 576;
pub const CKM_RIPEMD160_HMAC: ::std::os::raw::c_ulong = 577;
pub const CKM_RIPEMD160_HMAC_GENERAL: ::std::os::raw::c_ulong = 578;
pub const CKM_SHA256: ::std::os::raw::c_ulong = 592;
pub const CKM_SHA256_HMAC: ::std::os::raw::c_ulong = 593;
pub const CKM_SHA256_HMAC_GENERAL: ::std::os::raw::c_ulong = 594;
pub const CKM_SHA224: ::std::os::raw::c_ulong = 597;
pub const CKM_SHA224_HMAC: ::std::os::raw::c_ulong = 598;
pub const CKM_SHA224_HMAC_GENERAL: ::std::os::raw::c_ulong = 599;
pub const CKM_SHA384: ::std::os::raw::c_ulong = 608;
pub const CKM_SHA384_HMAC: ::std::os::raw::c_ulong = 609;
pub const CKM_SHA384_HMAC_GENERAL: ::std::os::raw::c_ulong = 610;
pub const CKM_SHA512: ::std::os::raw::c_ulong = 624;
pub const CKM_SHA512_HMAC: ::std::os::raw::c_ulong = 625;
pub const CKM_SHA512_HMAC_GENERAL: ::std::os::raw::c_ulong = 626;
pub const CKM_SECURID_KEY_GEN: ::std::os::raw::c_ulong = 640;
pub const CKM_SECURID: ::std::os::raw::c_ulong = 642;
pub const CKM_HOTP_KEY_GEN: ::std::os::raw::c_ulong = 656;
pub const CKM_HOTP: ::std::os::raw::c_ulong = 657;
pub const CKM_ACTI: ::std::os::raw::c_ulong = 672;
pub const CKM_ACTI_KEY_GEN: ::std::os::raw::c_ulong = 673;
pub const CKM_CAST_KEY_GEN: ::std::os::raw::c_ulong = 768;
pub const CKM_CAST_ECB: ::std::os::raw::c_ulong = 769;
pub const CKM_CAST_CBC: ::std::os::raw::c_ulong = 770;
pub const CKM_CAST_MAC: ::std::os::raw::c_ulong = 771;
pub const CKM_CAST_MAC_GENERAL: ::std::os::raw::c_ulong = 772;
pub const CKM_CAST_CBC_PAD: ::std::os::raw::c_ulong = 773;
pub const CKM_CAST3_KEY_GEN: ::std::os::raw::c_ulong = 784;
pub const CKM_CAST3_ECB: ::std::os::raw::c_ulong = 785;
pub const CKM_CAST3_CBC: ::std::os::raw::c_ulong = 786;
pub const CKM_CAST3_MAC: ::std::os::raw::c_ulong = 787;
pub const CKM_CAST3_MAC_GENERAL: ::std::os::raw::c_ulong = 788;
pub const CKM_CAST3_CBC_PAD: ::std::os::raw::c_ulong = 789;
pub const CKM_CAST128_KEY_GEN: ::std::os::raw::c_ulong = 800;
pub const CKM_CAST128_ECB: ::std::os::raw::c_ulong = 801;
pub const CKM_CAST128_CBC: ::std::os::raw::c_ulong = 802;
pub const CKM_CAST128_MAC: ::std::os::raw::c_ulong = 803;
pub const CKM_CAST128_MAC_GENERAL: ::std::os::raw::c_ulong = 804;
pub const CKM_CAST128_CBC_PAD: ::std::os::raw::c_ulong = 805;
pub const CKM_RC5_KEY_GEN: ::std::os::raw::c_ulong = 816;
pub const CKM_RC5_ECB: ::std::os::raw::c_ulong = 817;
pub const CKM_RC5_CBC: ::std::os::raw::c_ulong = 818;
pub const CKM_RC5_MAC: ::std::os::raw::c_ulong = 819;
pub const CKM_RC5_MAC_GENERAL: ::std::os::raw::c_ulong = 820;
pub const CKM_RC5_CBC_PAD: ::std::os::raw::c_ulong = 821;
pub const CKM_IDEA_KEY_GEN: ::std::os::raw::c_ulong = 832;
pub const CKM_IDEA_ECB: ::std::os::raw::c_ulong = 833;
pub const CKM_IDEA_CBC: ::std::os::raw::c_ulong = 834;
pub const CKM_IDEA_MAC: ::std::os::raw::c_ulong = 835;
pub const CKM_IDEA_MAC_GENERAL: ::std::os::raw::c_ulong = 836;
pub const CKM_IDEA_CBC_PAD: ::std::os::raw::c_ulong = 837;
pub const CKM_GENERIC_SECRET_KEY_GEN: ::std::os::raw::c_ulong = 848;
pub const CKM_CONCATENATE_BASE_AND_KEY: ::std::os::raw::c_ulong = 864;
pub const CKM_CONCATENATE_BASE_AND_DATA: ::std::os::raw::c_ulong = 866;
pub const CKM_CONCATENATE_DATA_AND_BASE: ::std::os::raw::c_ulong = 867;
pub const CKM_XOR_BASE_AND_DATA: ::std::os::raw::c_ulong = 868;
pub const CKM_EXTRACT_KEY_FROM_KEY: ::std::os::raw::c_ulong = 869;
pub const CKM_SSL3_PRE_MASTER_KEY_GEN: ::std::os::raw::c_ulong = 880;
pub const CKM_SSL3_MASTER_KEY_DERIVE: ::std::os::raw::c_ulong = 881;
pub const CKM_SSL3_KEY_AND_MAC_DERIVE: ::std::os::raw::c_ulong = 882;
pub const CKM_SSL3_MASTER_KEY_DERIVE_DH: ::std::os::raw::c_ulong = 883;
pub const CKM_TLS_PRE_MASTER_KEY_GEN: ::std::os::raw::c_ulong = 884;
pub const CKM_TLS_MASTER_KEY_DERIVE: ::std::os::raw::c_ulong = 885;
pub const CKM_TLS_KEY_AND_MAC_DERIVE: ::std::os::raw::c_ulong = 886;
pub const CKM_TLS_MASTER_KEY_DERIVE_DH: ::std::os::raw::c_ulong = 887;
pub const CKM_TLS_PRF: ::std::os::raw::c_ulong = 888;
pub const CKM_SSL3_MD5_MAC: ::std::os::raw::c_ulong = 896;
pub const CKM_SSL3_SHA1_MAC: ::std::os::raw::c_ulong = 897;
pub const CKM_MD5_KEY_DERIVATION: ::std::os::raw::c_ulong = 912;
pub const CKM_MD2_KEY_DERIVATION: ::std::os::raw::c_ulong = 913;
pub const CKM_SHA1_KEY_DERIVATION: ::std::os::raw::c_ulong = 914;
pub const CKM_SHA256_KEY_DERIVATION: ::std::os::raw::c_ulong = 915;
pub const CKM_SHA384_KEY_DERIVATION: ::std::os::raw::c_ulong = 916;
pub const CKM_SHA512_KEY_DERIVATION: ::std::os::raw::c_ulong = 917;
pub const CKM_SHA224_KEY_DERIVATION: ::std::os::raw::c_ulong = 918;
pub const CKM_PBE_MD2_DES_CBC: ::std::os::raw::c_ulong = 928;
pub const CKM_PBE_MD5_DES_CBC: ::std::os::raw::c_ulong = 929;
pub const CKM_PBE_MD5_CAST_CBC: ::std::os::raw::c_ulong = 930;
pub const CKM_PBE_MD5_CAST3_CBC: ::std::os::raw::c_ulong = 931;
pub const CKM_PBE_MD5_CAST128_CBC: ::std::os::raw::c_ulong = 932;
pub const CKM_PBE_SHA1_CAST128_CBC: ::std::os::raw::c_ulong = 933;
pub const CKM_PBE_SHA1_RC4_128: ::std::os::raw::c_ulong = 934;
pub const CKM_PBE_SHA1_RC4_40: ::std::os::raw::c_ulong = 935;
pub const CKM_PBE_SHA1_DES3_EDE_CBC: ::std::os::raw::c_ulong = 936;
pub const CKM_PBE_SHA1_DES2_EDE_CBC: ::std::os::raw::c_ulong = 937;
pub const CKM_PBE_SHA1_RC2_128_CBC: ::std::os::raw::c_ulong = 938;
pub const CKM_PBE_SHA1_RC2_40_CBC: ::std::os::raw::c_ulong = 939;
pub const CKM_PKCS5_PBKD2: ::std::os::raw::c_ulong = 944;
pub const CKM_PBA_SHA1_WITH_SHA1_HMAC: ::std::os::raw::c_ulong = 960;
pub const CKM_WTLS_PRE_MASTER_KEY_GEN: ::std::os::raw::c_ulong = 976;
pub const CKM_WTLS_MASTER_KEY_DERIVE: ::std::os::raw::c_ulong = 977;
pub const CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC: ::std::os::raw::c_ulong = 978;
pub const CKM_WTLS_PRF: ::std::os::raw::c_ulong = 979;
pub const CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE: ::std::os::raw::c_ulong = 980;
pub const CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE: ::std::os::raw::c_ulong = 981;
pub const CKM_TLS10_MAC_SERVER: ::std::os::raw::c_ulong = 982;
pub const CKM_TLS10_MAC_CLIENT: ::std::os::raw::c_ulong = 983;
pub const CKM_TLS12_MAC: ::std::os::raw::c_ulong = 984;
pub const CKM_TLS12_KDF: ::std::os::raw::c_ulong = 985;
pub const CKM_TLS12_MASTER_KEY_DERIVE: ::std::os::raw::c_ulong = 992;
pub const CKM_TLS12_KEY_AND_MAC_DERIVE: ::std::os::raw::c_ulong = 993;
pub const CKM_TLS12_MASTER_KEY_DERIVE_DH: ::std::os::raw::c_ulong = 994;
pub const CKM_TLS12_KEY_SAFE_DERIVE: ::std::os::raw::c_ulong = 995;
pub const CKM_TLS_MAC: ::std::os::raw::c_ulong = 996;
pub const CKM_TLS_KDF: ::std::os::raw::c_ulong = 997;
pub const CKM_KEY_WRAP_LYNKS: ::std::os::raw::c_ulong = 1024;
pub const CKM_KEY_WRAP_SET_OAEP: ::std::os::raw::c_ulong = 1025;
pub const CKM_CMS_SIG: ::std::os::raw::c_ulong = 1280;
pub const CKM_KIP_DERIVE: ::std::os::raw::c_ulong = 1296;
pub const CKM_KIP_WRAP: ::std::os::raw::c_ulong = 1297;
pub const CKM_KIP_MAC: ::std::os::raw::c_ulong = 1298;
pub const CKM_CAMELLIA_KEY_GEN: ::std::os::raw::c_ulong = 1360;
pub const CKM_CAMELLIA_ECB: ::std::os::raw::c_ulong = 1361;
pub const CKM_CAMELLIA_CBC: ::std::os::raw::c_ulong = 1362;
pub const CKM_CAMELLIA_MAC: ::std::os::raw::c_ulong = 1363;
pub const CKM_CAMELLIA_MAC_GENERAL: ::std::os::raw::c_ulong = 1364;
pub const CKM_CAMELLIA_CBC_PAD: ::std::os::raw::c_ulong = 1365;
pub const CKM_CAMELLIA_ECB_ENCRYPT_DATA: ::std::os::raw::c_ulong = 1366;
pub const CKM_CAMELLIA_CBC_ENCRYPT_DATA: ::std::os::raw::c_ulong = 1367;
pub const CKM_CAMELLIA_CTR: ::std::os::raw::c_ulong = 1368;
pub const CKM_ARIA_KEY_GEN: ::std::os::raw::c_ulong = 1376;
pub const CKM_ARIA_ECB: ::std::os::raw::c_ulong = 1377;
pub const CKM_ARIA_CBC: ::std::os::raw::c_ulong = 1378;
pub const CKM_ARIA_MAC: ::std::os::raw::c_ulong = 1379;
pub const CKM_ARIA_MAC_GENERAL: ::std::os::raw::c_ulong = 1380;
pub const CKM_ARIA_CBC_PAD: ::std::os::raw::c_ulong = 1381;
pub const CKM_ARIA_ECB_ENCRYPT_DATA: ::std::os::raw::c_ulong = 1382;
pub const CKM_ARIA_CBC_ENCRYPT_DATA: ::std::os::raw::c_ulong = 1383;
pub const CKM_SEED_KEY_GEN: ::std::os::raw::c_ulong = 1616;
pub const CKM_SEED_ECB: ::std::os::raw::c_ulong = 1617;
pub const CKM_SEED_CBC: ::std::os::raw::c_ulong = 1618;
pub const CKM_SEED_MAC: ::std::os::raw::c_ulong = 1619;
pub const CKM_SEED_MAC_GENERAL: ::std::os::raw::c_ulong = 1620;
pub const CKM_SEED_CBC_PAD: ::std::os::raw::c_ulong = 1621;
pub const CKM_SEED_ECB_ENCRYPT_DATA: ::std::os::raw::c_ulong = 1622;
pub const CKM_SEED_CBC_ENCRYPT_DATA: ::std::os::raw::c_ulong = 1623;
pub const CKM_SKIPJACK_KEY_GEN: ::std::os::raw::c_ulong = 4096;
pub const CKM_SKIPJACK_ECB64: ::std::os::raw::c_ulong = 4097;
pub const CKM_SKIPJACK_CBC64: ::std::os::raw::c_ulong = 4098;
pub const CKM_SKIPJACK_OFB64: ::std::os::raw::c_ulong = 4099;
pub const CKM_SKIPJACK_CFB64: ::std::os::raw::c_ulong = 4100;
pub const CKM_SKIPJACK_CFB32: ::std::os::raw::c_ulong = 4101;
pub const CKM_SKIPJACK_CFB16: ::std::os::raw::c_ulong = 4102;
pub const CKM_SKIPJACK_CFB8: ::std::os::raw::c_ulong = 4103;
pub const CKM_SKIPJACK_WRAP: ::std::os::raw::c_ulong = 4104;
pub const CKM_SKIPJACK_PRIVATE_WRAP: ::std::os::raw::c_ulong = 4105;
pub const CKM_SKIPJACK_RELAYX: ::std::os::raw::c_ulong = 4106;
pub const CKM_KEA_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 4112;
pub const CKM_KEA_KEY_DERIVE: ::std::os::raw::c_ulong = 4113;
pub const CKM_KEA_DERIVE: ::std::os::raw::c_ulong = 4114;
pub const CKM_FORTEZZA_TIMESTAMP: ::std::os::raw::c_ulong = 4128;
pub const CKM_BATON_KEY_GEN: ::std::os::raw::c_ulong = 4144;
pub const CKM_BATON_ECB128: ::std::os::raw::c_ulong = 4145;
pub const CKM_BATON_ECB96: ::std::os::raw::c_ulong = 4146;
pub const CKM_BATON_CBC128: ::std::os::raw::c_ulong = 4147;
pub const CKM_BATON_COUNTER: ::std::os::raw::c_ulong = 4148;
pub const CKM_BATON_SHUFFLE: ::std::os::raw::c_ulong = 4149;
pub const CKM_BATON_WRAP: ::std::os::raw::c_ulong = 4150;
pub const CKM_EC_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 4160;
pub const CKM_ECDSA: ::std::os::raw::c_ulong = 4161;
pub const CKM_ECDSA_SHA1: ::std::os::raw::c_ulong = 4162;
pub const CKM_ECDSA_SHA224: ::std::os::raw::c_ulong = 4163;
pub const CKM_ECDSA_SHA256: ::std::os::raw::c_ulong = 4164;
pub const CKM_ECDSA_SHA384: ::std::os::raw::c_ulong = 4165;
pub const CKM_ECDSA_SHA512: ::std::os::raw::c_ulong = 4166;
pub const CKM_ECDH1_DERIVE: ::std::os::raw::c_ulong = 4176;
pub const CKM_ECDH1_COFACTOR_DERIVE: ::std::os::raw::c_ulong = 4177;
pub const CKM_ECMQV_DERIVE: ::std::os::raw::c_ulong = 4178;
pub const CKM_ECDH_AES_KEY_WRAP: ::std::os::raw::c_ulong = 4179;
pub const CKM_RSA_AES_KEY_WRAP: ::std::os::raw::c_ulong = 4180;
pub const CKM_JUNIPER_KEY_GEN: ::std::os::raw::c_ulong = 4192;
pub const CKM_JUNIPER_ECB128: ::std::os::raw::c_ulong = 4193;
pub const CKM_JUNIPER_CBC128: ::std::os::raw::c_ulong = 4194;
pub const CKM_JUNIPER_COUNTER: ::std::os::raw::c_ulong = 4195;
pub const CKM_JUNIPER_SHUFFLE: ::std::os::raw::c_ulong = 4196;
pub const CKM_JUNIPER_WRAP: ::std::os::raw::c_ulong = 4197;
pub const CKM_FASTHASH: ::std::os::raw::c_ulong = 4208;
pub const CKM_AES_KEY_GEN: ::std::os::raw::c_ulong = 4224;
pub const CKM_AES_ECB: ::std::os::raw::c_ulong = 4225;
pub const CKM_AES_CBC: ::std::os::raw::c_ulong = 4226;
pub const CKM_AES_MAC: ::std::os::raw::c_ulong = 4227;
pub const CKM_AES_MAC_GENERAL: ::std::os::raw::c_ulong = 4228;
pub const CKM_AES_CBC_PAD: ::std::os::raw::c_ulong = 4229;
pub const CKM_AES_CTR: ::std::os::raw::c_ulong = 4230;
pub const CKM_AES_GCM: ::std::os::raw::c_ulong = 4231;
pub const CKM_AES_CCM: ::std::os::raw::c_ulong = 4232;
pub const CKM_AES_CTS: ::std::os::raw::c_ulong = 4233;
pub const CKM_AES_CMAC: ::std::os::raw::c_ulong = 4234;
pub const CKM_AES_CMAC_GENERAL: ::std::os::raw::c_ulong = 4235;
pub const CKM_AES_XCBC_MAC: ::std::os::raw::c_ulong = 4236;
pub const CKM_AES_XCBC_MAC_96: ::std::os::raw::c_ulong = 4237;
pub const CKM_AES_GMAC: ::std::os::raw::c_ulong = 4238;
pub const CKM_BLOWFISH_KEY_GEN: ::std::os::raw::c_ulong = 4240;
pub const CKM_BLOWFISH_CBC: ::std::os::raw::c_ulong = 4241;
pub const CKM_TWOFISH_KEY_GEN: ::std::os::raw::c_ulong = 4242;
pub const CKM_TWOFISH_CBC: ::std::os::raw::c_ulong = 4243;
pub const CKM_BLOWFISH_CBC_PAD: ::std::os::raw::c_ulong = 4244;
pub const CKM_TWOFISH_CBC_PAD: ::std::os::raw::c_ulong = 4245;
pub const CKM_DES_ECB_ENCRYPT_DATA: ::std::os::raw::c_ulong = 4352;
pub const CKM_DES_CBC_ENCRYPT_DATA: ::std::os::raw::c_ulong = 4353;
pub const CKM_DES3_ECB_ENCRYPT_DATA: ::std::os::raw::c_ulong = 4354;
pub const CKM_DES3_CBC_ENCRYPT_DATA: ::std::os::raw::c_ulong = 4355;
pub const CKM_AES_ECB_ENCRYPT_DATA: ::std::os::raw::c_ulong = 4356;
pub const CKM_AES_CBC_ENCRYPT_DATA: ::std::os::raw::c_ulong = 4357;
pub const CKM_GOSTR3410_KEY_PAIR_GEN: ::std::os::raw::c_ulong = 4608;
pub const CKM_GOSTR3410: ::std::os::raw::c_ulong = 4609;
pub const CKM_GOSTR3410_WITH_GOSTR3411: ::std::os::raw::c_ulong = 4610;
pub const CKM_GOSTR3410_KEY_WRAP: ::std::os::raw::c_ulong = 4611;
pub const CKM_GOSTR3410_DERIVE: ::std::os::raw::c_ulong = 4612;
pub const CKM_GOSTR3411: ::std::os::raw::c_ulong = 4624;
pub const CKM_GOSTR3411_HMAC: ::std::os::raw::c_ulong = 4625;
pub const CKM_GOST28147_KEY_GEN: ::std::os::raw::c_ulong = 4640;
pub const CKM_GOST28147_ECB: ::std::os::raw::c_ulong = 4641;
pub const CKM_GOST28147: ::std::os::raw::c_ulong = 4642;
pub const CKM_GOST28147_MAC: ::std::os::raw::c_ulong = 4643;
pub const CKM_GOST28147_KEY_WRAP: ::std::os::raw::c_ulong = 4644;
pub const CKM_DSA_PARAMETER_GEN: ::std::os::raw::c_ulong = 8192;
pub const CKM_DH_PKCS_PARAMETER_GEN: ::std::os::raw::c_ulong = 8193;
pub const CKM_X9_42_DH_PARAMETER_GEN: ::std::os::raw::c_ulong = 8194;
pub const CKM_DSA_PROBABLISTIC_PARAMETER_GEN: ::std::os::raw::c_ulong = 8195;
pub const CKM_DSA_SHAWE_TAYLOR_PARAMETER_GEN: ::std::os::raw::c_ulong = 8196;
pub const CKM_AES_OFB: ::std::os::raw::c_ulong = 8452;
pub const CKM_AES_CFB64: ::std::os::raw::c_ulong = 8453;
pub const CKM_AES_CFB8: ::std::os::raw::c_ulong = 8454;
pub const CKM_AES_CFB128: ::std::os::raw::c_ulong = 8455;
pub const CKM_AES_CFB1: ::std::os::raw::c_ulong = 8456;
pub const CKM_AES_KEY_WRAP: ::std::os::raw::c_ulong = 8457;
pub const CKM_AES_KEY_WRAP_PAD: ::std::os::raw::c_ulong = 8458;
pub const CKM_RSA_PKCS_TPM_1_1: ::std::os::raw::c_ulong = 16385;
pub const CKM_RSA_PKCS_OAEP_TPM_1_1: ::std::os::raw::c_ulong = 16386;
pub const CKM_VENDOR_DEFINED: ::std::os::raw::c_ulong = 2147483648;
pub const CKF_HW: ::std::os::raw::c_ulong = 1;
pub const CKF_ENCRYPT: ::std::os::raw::c_ulong = 256;
pub const CKF_DECRYPT: ::std::os::raw::c_ulong = 512;
pub const CKF_DIGEST: ::std::os::raw::c_ulong = 1024;
pub const CKF_SIGN: ::std::os::raw::c_ulong = 2048;
pub const CKF_SIGN_RECOVER: ::std::os::raw::c_ulong = 4096;
pub const CKF_VERIFY: ::std::os::raw::c_ulong = 8192;
pub const CKF_VERIFY_RECOVER: ::std::os::raw::c_ulong = 16384;
pub const CKF_GENERATE: ::std::os::raw::c_ulong = 32768;
pub const CKF_GENERATE_KEY_PAIR: ::std::os::raw::c_ulong = 65536;
pub const CKF_WRAP: ::std::os::raw::c_ulong = 131072;
pub const CKF_UNWRAP: ::std::os::raw::c_ulong = 262144;
pub const CKF_DERIVE: ::std::os::raw::c_ulong = 524288;
pub const CKF_EC_F_P: ::std::os::raw::c_ulong = 1048576;
pub const CKF_EC_F_2M: ::std::os::raw::c_ulong = 2097152;
pub const CKF_EC_ECPARAMETERS: ::std::os::raw::c_ulong = 4194304;
pub const CKF_EC_NAMEDCURVE: ::std::os::raw::c_ulong = 8388608;
pub const CKF_EC_UNCOMPRESS: ::std::os::raw::c_ulong = 16777216;
pub const CKF_EC_COMPRESS: ::std::os::raw::c_ulong = 33554432;
pub const CKF_EXTENSION: ::std::os::raw::c_ulong = 2147483648;
pub const CKR_OK: ::std::os::raw::c_ulong = 0;
pub const CKR_CANCEL: ::std::os::raw::c_ulong = 1;
pub const CKR_HOST_MEMORY: ::std::os::raw::c_ulong = 2;
pub const CKR_SLOT_ID_INVALID: ::std::os::raw::c_ulong = 3;
pub const CKR_GENERAL_ERROR: ::std::os::raw::c_ulong = 5;
pub const CKR_FUNCTION_FAILED: ::std::os::raw::c_ulong = 6;
pub const CKR_ARGUMENTS_BAD: ::std::os::raw::c_ulong = 7;
pub const CKR_NO_EVENT: ::std::os::raw::c_ulong = 8;
pub const CKR_NEED_TO_CREATE_THREADS: ::std::os::raw::c_ulong = 9;
pub const CKR_CANT_LOCK: ::std::os::raw::c_ulong = 10;
pub const CKR_ATTRIBUTE_READ_ONLY: ::std::os::raw::c_ulong = 16;
pub const CKR_ATTRIBUTE_SENSITIVE: ::std::os::raw::c_ulong = 17;
pub const CKR_ATTRIBUTE_TYPE_INVALID: ::std::os::raw::c_ulong = 18;
pub const CKR_ATTRIBUTE_VALUE_INVALID: ::std::os::raw::c_ulong = 19;
pub const CKR_ACTION_PROHIBITED: ::std::os::raw::c_ulong = 27;
pub const CKR_DATA_INVALID: ::std::os::raw::c_ulong = 32;
pub const CKR_DATA_LEN_RANGE: ::std::os::raw::c_ulong = 33;
pub const CKR_DEVICE_ERROR: ::std::os::raw::c_ulong = 48;
pub const CKR_DEVICE_MEMORY: ::std::os::raw::c_ulong = 49;
pub const CKR_DEVICE_REMOVED: ::std::os::raw::c_ulong = 50;
pub const CKR_ENCRYPTED_DATA_INVALID: ::std::os::raw::c_ulong = 64;
pub const CKR_ENCRYPTED_DATA_LEN_RANGE: ::std::os::raw::c_ulong = 65;
pub const CKR_FUNCTION_CANCELED: ::std::os::raw::c_ulong = 80;
pub const CKR_FUNCTION_NOT_PARALLEL: ::std::os::raw::c_ulong = 81;
pub const CKR_FUNCTION_NOT_SUPPORTED: ::std::os::raw::c_ulong = 84;
pub const CKR_KEY_HANDLE_INVALID: ::std::os::raw::c_ulong = 96;
pub const CKR_KEY_SIZE_RANGE: ::std::os::raw::c_ulong = 98;
pub const CKR_KEY_TYPE_INCONSISTENT: ::std::os::raw::c_ulong = 99;
pub const CKR_KEY_NOT_NEEDED: ::std::os::raw::c_ulong = 100;
pub const CKR_KEY_CHANGED: ::std::os::raw::c_ulong = 101;
pub const CKR_KEY_NEEDED: ::std::os::raw::c_ulong = 102;
pub const CKR_KEY_INDIGESTIBLE: ::std::os::raw::c_ulong = 103;
pub const CKR_KEY_FUNCTION_NOT_PERMITTED: ::std::os::raw::c_ulong = 104;
pub const CKR_KEY_NOT_WRAPPABLE: ::std::os::raw::c_ulong = 105;
pub const CKR_KEY_UNEXTRACTABLE: ::std::os::raw::c_ulong = 106;
pub const CKR_MECHANISM_INVALID: ::std::os::raw::c_ulong = 112;
pub const CKR_MECHANISM_PARAM_INVALID: ::std::os::raw::c_ulong = 113;
pub const CKR_OBJECT_HANDLE_INVALID: ::std::os::raw::c_ulong = 130;
pub const CKR_OPERATION_ACTIVE: ::std::os::raw::c_ulong = 144;
pub const CKR_OPERATION_NOT_INITIALIZED: ::std::os::raw::c_ulong = 145;
pub const CKR_PIN_INCORRECT: ::std::os::raw::c_ulong = 160;
pub const CKR_PIN_INVALID: ::std::os::raw::c_ulong = 161;
pub const CKR_PIN_LEN_RANGE: ::std::os::raw::c_ulong = 162;
pub const CKR_PIN_EXPIRED: ::std::os::raw::c_ulong = 163;
pub const CKR_PIN_LOCKED: ::std::os::raw::c_ulong = 164;
pub const CKR_SESSION_CLOSED: ::std::os::raw::c_ulong = 176;
pub const CKR_SESSION_COUNT: ::std::os::raw::c_ulong = 177;
pub const CKR_SESSION_HANDLE_INVALID: ::std::os::raw::c_ulong = 179;
pub const CKR_SESSION_PARALLEL_NOT_SUPPORTED: ::std::os::raw::c_ulong = 180;
pub const CKR_SESSION_READ_ONLY: ::std::os::raw::c_ulong = 181;
pub const CKR_SESSION_EXISTS: ::std::os::raw::c_ulong = 182;
pub const CKR_SESSION_READ_ONLY_EXISTS: ::std::os::raw::c_ulong = 183;
pub const CKR_SESSION_READ_WRITE_SO_EXISTS: ::std::os::raw::c_ulong = 184;
pub const CKR_SIGNATURE_INVALID: ::std::os::raw::c_ulong = 192;
pub const CKR_SIGNATURE_LEN_RANGE: ::std::os::raw::c_ulong = 193;
pub const CKR_TEMPLATE_INCOMPLETE: ::std::os::raw::c_ulong = 208;
pub const CKR_TEMPLATE_INCONSISTENT: ::std::os::raw::c_ulong = 209;
pub const CKR_TOKEN_NOT_PRESENT: ::std::os::raw::c_ulong = 224;
pub const CKR_TOKEN_NOT_RECOGNIZED: ::std::os::raw::c_ulong = 225;
pub const CKR_TOKEN_WRITE_PROTECTED: ::std::os::raw::c_ulong = 226;
pub const CKR_UNWRAPPING_KEY_HANDLE_INVALID: ::std::os::raw::c_ulong = 240;
pub const CKR_UNWRAPPING_KEY_SIZE_RANGE: ::std::os::raw::c_ulong = 241;
pub const CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT: ::std::os::raw::c_ulong = 242;
pub const CKR_USER_ALREADY_LOGGED_IN: ::std::os::raw::c_ulong = 256;
pub const CKR_USER_NOT_LOGGED_IN: ::std::os::raw::c_ulong = 257;
pub const CKR_USER_PIN_NOT_INITIALIZED: ::std::os::raw::c_ulong = 258;
pub const CKR_USER_TYPE_INVALID: ::std::os::raw::c_ulong = 259;
pub const CKR_USER_ANOTHER_ALREADY_LOGGED_IN: ::std::os::raw::c_ulong = 260;
pub const CKR_USER_TOO_MANY_TYPES: ::std::os::raw::c_ulong = 261;
pub const CKR_WRAPPED_KEY_INVALID: ::std::os::raw::c_ulong = 272;
pub const CKR_WRAPPED_KEY_LEN_RANGE: ::std::os::raw::c_ulong = 274;
pub const CKR_WRAPPING_KEY_HANDLE_INVALID: ::std::os::raw::c_ulong = 275;
pub const CKR_WRAPPING_KEY_SIZE_RANGE: ::std::os::raw::c_ulong = 276;
pub const CKR_WRAPPING_KEY_TYPE_INCONSISTENT: ::std::os::raw::c_ulong = 277;
pub const CKR_RANDOM_SEED_NOT_SUPPORTED: ::std::os::raw::c_ulong = 288;
pub const CKR_RANDOM_NO_RNG: ::std::os::raw::c_ulong = 289;
pub const CKR_DOMAIN_PARAMS_INVALID: ::std::os::raw::c_ulong = 304;
pub const CKR_CURVE_NOT_SUPPORTED: ::std::os::raw::c_ulong = 320;
pub const CKR_BUFFER_TOO_SMALL: ::std::os::raw::c_ulong = 336;
pub const CKR_SAVED_STATE_INVALID: ::std::os::raw::c_ulong = 352;
pub const CKR_INFORMATION_SENSITIVE: ::std::os::raw::c_ulong = 368;
pub const CKR_STATE_UNSAVEABLE: ::std::os::raw::c_ulong = 384;
pub const CKR_CRYPTOKI_NOT_INITIALIZED: ::std::os::raw::c_ulong = 400;
pub const CKR_CRYPTOKI_ALREADY_INITIALIZED: ::std::os::raw::c_ulong = 401;
pub const CKR_MUTEX_BAD: ::std::os::raw::c_ulong = 416;
pub const CKR_MUTEX_NOT_LOCKED: ::std::os::raw::c_ulong = 417;
pub const CKR_NEW_PIN_MODE: ::std::os::raw::c_ulong = 432;
pub const CKR_NEXT_OTP: ::std::os::raw::c_ulong = 433;
pub const CKR_EXCEEDED_MAX_ITERATIONS: ::std::os::raw::c_ulong = 437;
pub const CKR_FIPS_SELF_TEST_FAILED: ::std::os::raw::c_ulong = 438;
pub const CKR_LIBRARY_LOAD_FAILED: ::std::os::raw::c_ulong = 439;
pub const CKR_PIN_TOO_WEAK: ::std::os::raw::c_ulong = 440;
pub const CKR_PUBLIC_KEY_INVALID: ::std::os::raw::c_ulong = 441;
pub const CKR_FUNCTION_REJECTED: ::std::os::raw::c_ulong = 512;
pub const CKR_VENDOR_DEFINED: ::std::os::raw::c_ulong = 2147483648;
pub const CKF_LIBRARY_CANT_CREATE_OS_THREADS: ::std::os::raw::c_ulong = 1;
pub const CKF_OS_LOCKING_OK: ::std::os::raw::c_ulong = 2;
pub const CKF_DONT_BLOCK: ::std::os::raw::c_ulong = 1;
pub const CKG_MGF1_SHA1: ::std::os::raw::c_ulong = 1;
pub const CKG_MGF1_SHA256: ::std::os::raw::c_ulong = 2;
pub const CKG_MGF1_SHA384: ::std::os::raw::c_ulong = 3;
pub const CKG_MGF1_SHA512: ::std::os::raw::c_ulong = 4;
pub const CKG_MGF1_SHA224: ::std::os::raw::c_ulong = 5;
pub const CKZ_DATA_SPECIFIED: ::std::os::raw::c_ulong = 1;
pub const CKD_NULL: ::std::os::raw::c_ulong = 1;
pub const CKD_SHA1_KDF: ::std::os::raw::c_ulong = 2;
pub const CKD_SHA1_KDF_ASN1: ::std::os::raw::c_ulong = 3;
pub const CKD_SHA1_KDF_CONCATENATE: ::std::os::raw::c_ulong = 4;
pub const CKD_SHA224_KDF: ::std::os::raw::c_ulong = 5;
pub const CKD_SHA256_KDF: ::std::os::raw::c_ulong = 6;
pub const CKD_SHA384_KDF: ::std::os::raw::c_ulong = 7;
pub const CKD_SHA512_KDF: ::std::os::raw::c_ulong = 8;
pub const CKD_CPDIVERSIFY_KDF: ::std::os::raw::c_ulong = 9;
pub const CKP_PKCS5_PBKD2_HMAC_SHA1: ::std::os::raw::c_ulong = 1;
pub const CKP_PKCS5_PBKD2_HMAC_GOSTR3411: ::std::os::raw::c_ulong = 2;
pub const CKP_PKCS5_PBKD2_HMAC_SHA224: ::std::os::raw::c_ulong = 3;
pub const CKP_PKCS5_PBKD2_HMAC_SHA256: ::std::os::raw::c_ulong = 4;
pub const CKP_PKCS5_PBKD2_HMAC_SHA384: ::std::os::raw::c_ulong = 5;
pub const CKP_PKCS5_PBKD2_HMAC_SHA512: ::std::os::raw::c_ulong = 6;
pub const CKP_PKCS5_PBKD2_HMAC_SHA512_224: ::std::os::raw::c_ulong = 7;
pub const CKP_PKCS5_PBKD2_HMAC_SHA512_256: ::std::os::raw::c_ulong = 8;
pub const CKZ_SALT_SPECIFIED: ::std::os::raw::c_ulong = 1;
pub const CK_OTP_VALUE: ::std::os::raw::c_ulong = 0;
pub const CK_OTP_PIN: ::std::os::raw::c_ulong = 1;
pub const CK_OTP_CHALLENGE: ::std::os::raw::c_ulong = 2;
pub const CK_OTP_TIME: ::std::os::raw::c_ulong = 3;
pub const CK_OTP_COUNTER: ::std::os::raw::c_ulong = 4;
pub const CK_OTP_FLAGS: ::std::os::raw::c_ulong = 5;
pub const CK_OTP_OUTPUT_LENGTH: ::std::os::raw::c_ulong = 6;
pub const CK_OTP_OUTPUT_FORMAT: ::std::os::raw::c_ulong = 7;
pub const CKF_NEXT_OTP: ::std::os::raw::c_ulong = 1;
pub const CKF_EXCLUDE_TIME: ::std::os::raw::c_ulong = 2;
pub const CKF_EXCLUDE_COUNTER: ::std::os::raw::c_ulong = 4;
pub const CKF_EXCLUDE_CHALLENGE: ::std::os::raw::c_ulong = 8;
pub const CKF_EXCLUDE_PIN: ::std::os::raw::c_ulong = 16;
pub const CKF_USER_FRIENDLY_OTP: ::std::os::raw::c_ulong = 32;
pub const CK_NEED_ARG_LIST: ::std::os::raw::c_ulong = 1;
pub type CK_BYTE = ::std::os::raw::c_uchar;
pub type CK_CHAR = CK_BYTE;
pub type CK_UTF8CHAR = CK_BYTE;
pub type CK_BBOOL = CK_BYTE;
pub type CK_ULONG = ::std::os::raw::c_ulong;
pub type CK_LONG = ::std::os::raw::c_long;
pub type CK_FLAGS = CK_ULONG;
pub const CK_UNAVAILABLE_INFORMATION: CK_ULONG = 4294967295;
pub type CK_BYTE_PTR = *mut CK_BYTE;
pub type CK_CHAR_PTR = *mut CK_CHAR;
pub type CK_UTF8CHAR_PTR = *mut CK_UTF8CHAR;
pub type CK_ULONG_PTR = *mut CK_ULONG;
pub type CK_VOID_PTR = *mut ::std::os::raw::c_void;
pub type CK_VOID_PTR_PTR = *mut CK_VOID_PTR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_VERSION {
    pub major: CK_BYTE,
    pub minor: CK_BYTE,
}
#[test]
fn bindgen_test_layout_CK_VERSION() {
    assert_eq!(
        ::std::mem::size_of::<CK_VERSION>(),
        2usize,
        concat!("Size of: ", stringify!(CK_VERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_VERSION>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_VERSION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_VERSION>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_VERSION),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_VERSION>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_VERSION),
            "::",
            stringify!(minor)
        )
    );
}
pub type CK_VERSION_PTR = *mut CK_VERSION;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_INFO {
    pub cryptokiVersion: CK_VERSION,
    pub manufacturerID: [CK_UTF8CHAR; 32usize],
    pub flags: CK_FLAGS,
    pub libraryDescription: [CK_UTF8CHAR; 32usize],
    pub libraryVersion: CK_VERSION,
}
#[test]
fn bindgen_test_layout_CK_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CK_INFO>(),
        72usize,
        concat!("Size of: ", stringify!(CK_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_INFO>())).cryptokiVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_INFO),
            "::",
            stringify!(cryptokiVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_INFO>())).manufacturerID as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_INFO),
            "::",
            stringify!(manufacturerID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_INFO>())).flags as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_INFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_INFO>())).libraryDescription as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_INFO),
            "::",
            stringify!(libraryDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_INFO>())).libraryVersion as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_INFO),
            "::",
            stringify!(libraryVersion)
        )
    );
}
pub type CK_INFO_PTR = *mut CK_INFO;
pub type CK_NOTIFICATION = CK_ULONG;
pub type CK_SLOT_ID = CK_ULONG;
pub type CK_SLOT_ID_PTR = *mut CK_SLOT_ID;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SLOT_INFO {
    pub slotDescription: [CK_UTF8CHAR; 64usize],
    pub manufacturerID: [CK_UTF8CHAR; 32usize],
    pub flags: CK_FLAGS,
    pub hardwareVersion: CK_VERSION,
    pub firmwareVersion: CK_VERSION,
}
#[test]
fn bindgen_test_layout_CK_SLOT_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CK_SLOT_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(CK_SLOT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SLOT_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SLOT_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SLOT_INFO>())).slotDescription as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SLOT_INFO),
            "::",
            stringify!(slotDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SLOT_INFO>())).manufacturerID as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SLOT_INFO),
            "::",
            stringify!(manufacturerID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SLOT_INFO>())).flags as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SLOT_INFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SLOT_INFO>())).hardwareVersion as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SLOT_INFO),
            "::",
            stringify!(hardwareVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SLOT_INFO>())).firmwareVersion as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SLOT_INFO),
            "::",
            stringify!(firmwareVersion)
        )
    );
}
impl Default for CK_SLOT_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_SLOT_INFO_PTR = *mut CK_SLOT_INFO;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_TOKEN_INFO {
    pub label: [CK_UTF8CHAR; 32usize],
    pub manufacturerID: [CK_UTF8CHAR; 32usize],
    pub model: [CK_UTF8CHAR; 16usize],
    pub serialNumber: [CK_CHAR; 16usize],
    pub flags: CK_FLAGS,
    pub ulMaxSessionCount: CK_ULONG,
    pub ulSessionCount: CK_ULONG,
    pub ulMaxRwSessionCount: CK_ULONG,
    pub ulRwSessionCount: CK_ULONG,
    pub ulMaxPinLen: CK_ULONG,
    pub ulMinPinLen: CK_ULONG,
    pub ulTotalPublicMemory: CK_ULONG,
    pub ulFreePublicMemory: CK_ULONG,
    pub ulTotalPrivateMemory: CK_ULONG,
    pub ulFreePrivateMemory: CK_ULONG,
    pub hardwareVersion: CK_VERSION,
    pub firmwareVersion: CK_VERSION,
    pub utcTime: [CK_CHAR; 16usize],
}
#[test]
fn bindgen_test_layout_CK_TOKEN_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CK_TOKEN_INFO>(),
        160usize,
        concat!("Size of: ", stringify!(CK_TOKEN_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_TOKEN_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_TOKEN_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).manufacturerID as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(manufacturerID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).model as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).serialNumber as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(serialNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).flags as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulMaxSessionCount as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulMaxSessionCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulSessionCount as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulSessionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulMaxRwSessionCount as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulMaxRwSessionCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulRwSessionCount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulRwSessionCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulMaxPinLen as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulMaxPinLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulMinPinLen as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulMinPinLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulTotalPublicMemory as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulTotalPublicMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulFreePublicMemory as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulFreePublicMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulTotalPrivateMemory as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulTotalPrivateMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TOKEN_INFO>())).ulFreePrivateMemory as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(ulFreePrivateMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).hardwareVersion as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(hardwareVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).firmwareVersion as *const _ as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(firmwareVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TOKEN_INFO>())).utcTime as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TOKEN_INFO),
            "::",
            stringify!(utcTime)
        )
    );
}
pub type CK_TOKEN_INFO_PTR = *mut CK_TOKEN_INFO;
pub type CK_SESSION_HANDLE = CK_ULONG;
pub type CK_SESSION_HANDLE_PTR = *mut CK_SESSION_HANDLE;
pub type CK_USER_TYPE = CK_ULONG;
pub type CK_STATE = CK_ULONG;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_SESSION_INFO {
    pub slotID: CK_SLOT_ID,
    pub state: CK_STATE,
    pub flags: CK_FLAGS,
    pub ulDeviceError: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_SESSION_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CK_SESSION_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(CK_SESSION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SESSION_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SESSION_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SESSION_INFO>())).slotID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SESSION_INFO),
            "::",
            stringify!(slotID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SESSION_INFO>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SESSION_INFO),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SESSION_INFO>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SESSION_INFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SESSION_INFO>())).ulDeviceError as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SESSION_INFO),
            "::",
            stringify!(ulDeviceError)
        )
    );
}
pub type CK_SESSION_INFO_PTR = *mut CK_SESSION_INFO;
pub type CK_OBJECT_HANDLE = CK_ULONG;
pub type CK_OBJECT_HANDLE_PTR = *mut CK_OBJECT_HANDLE;
pub type CK_OBJECT_CLASS = CK_ULONG;
pub type CK_OBJECT_CLASS_PTR = *mut CK_OBJECT_CLASS;
pub type CK_HW_FEATURE_TYPE = CK_ULONG;
pub type CK_KEY_TYPE = CK_ULONG;
pub type CK_CERTIFICATE_TYPE = CK_ULONG;
pub type CK_ATTRIBUTE_TYPE = CK_ULONG;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_ATTRIBUTE {
    pub type_: CK_ATTRIBUTE_TYPE,
    pub pValue: CK_VOID_PTR,
    pub ulValueLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_ATTRIBUTE() {
    assert_eq!(
        ::std::mem::size_of::<CK_ATTRIBUTE>(),
        12usize,
        concat!("Size of: ", stringify!(CK_ATTRIBUTE))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_ATTRIBUTE>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_ATTRIBUTE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_ATTRIBUTE>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ATTRIBUTE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_ATTRIBUTE>())).pValue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ATTRIBUTE),
            "::",
            stringify!(pValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_ATTRIBUTE>())).ulValueLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ATTRIBUTE),
            "::",
            stringify!(ulValueLen)
        )
    );
}
impl Default for CK_ATTRIBUTE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_ATTRIBUTE_PTR = *mut CK_ATTRIBUTE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_DATE {
    pub year: [CK_CHAR; 4usize],
    pub month: [CK_CHAR; 2usize],
    pub day: [CK_CHAR; 2usize],
}
#[test]
fn bindgen_test_layout_CK_DATE() {
    assert_eq!(
        ::std::mem::size_of::<CK_DATE>(),
        8usize,
        concat!("Size of: ", stringify!(CK_DATE))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_DATE>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_DATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_DATE>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DATE),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_DATE>())).month as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DATE),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_DATE>())).day as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DATE),
            "::",
            stringify!(day)
        )
    );
}
pub type CK_MECHANISM_TYPE = CK_ULONG;
pub type CK_MECHANISM_TYPE_PTR = *mut CK_MECHANISM_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_MECHANISM {
    pub mechanism: CK_MECHANISM_TYPE,
    pub pParameter: CK_VOID_PTR,
    pub ulParameterLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_MECHANISM() {
    assert_eq!(
        ::std::mem::size_of::<CK_MECHANISM>(),
        12usize,
        concat!("Size of: ", stringify!(CK_MECHANISM))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_MECHANISM>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_MECHANISM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_MECHANISM>())).mechanism as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_MECHANISM),
            "::",
            stringify!(mechanism)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_MECHANISM>())).pParameter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_MECHANISM),
            "::",
            stringify!(pParameter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_MECHANISM>())).ulParameterLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_MECHANISM),
            "::",
            stringify!(ulParameterLen)
        )
    );
}
impl Default for CK_MECHANISM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_MECHANISM_PTR = *mut CK_MECHANISM;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_MECHANISM_INFO {
    pub ulMinKeySize: CK_ULONG,
    pub ulMaxKeySize: CK_ULONG,
    pub flags: CK_FLAGS,
}
#[test]
fn bindgen_test_layout_CK_MECHANISM_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CK_MECHANISM_INFO>(),
        12usize,
        concat!("Size of: ", stringify!(CK_MECHANISM_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_MECHANISM_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_MECHANISM_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_MECHANISM_INFO>())).ulMinKeySize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_MECHANISM_INFO),
            "::",
            stringify!(ulMinKeySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_MECHANISM_INFO>())).ulMaxKeySize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_MECHANISM_INFO),
            "::",
            stringify!(ulMaxKeySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_MECHANISM_INFO>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_MECHANISM_INFO),
            "::",
            stringify!(flags)
        )
    );
}
pub type CK_MECHANISM_INFO_PTR = *mut CK_MECHANISM_INFO;
pub type CK_RV = CK_ULONG;
pub type CK_NOTIFY = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        event: CK_NOTIFICATION,
        pApplication: CK_VOID_PTR,
    ) -> CK_RV,
>;
pub type CK_FUNCTION_LIST_PTR = *mut CK_FUNCTION_LIST;
pub type CK_FUNCTION_LIST_PTR_PTR = *mut CK_FUNCTION_LIST_PTR;
pub type CK_CREATEMUTEX =
    ::std::option::Option<unsafe extern "C" fn(ppMutex: CK_VOID_PTR_PTR) -> CK_RV>;
pub type CK_DESTROYMUTEX =
    ::std::option::Option<unsafe extern "C" fn(pMutex: CK_VOID_PTR) -> CK_RV>;
pub type CK_LOCKMUTEX = ::std::option::Option<unsafe extern "C" fn(pMutex: CK_VOID_PTR) -> CK_RV>;
pub type CK_UNLOCKMUTEX = ::std::option::Option<unsafe extern "C" fn(pMutex: CK_VOID_PTR) -> CK_RV>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_C_INITIALIZE_ARGS {
    pub CreateMutex: CK_CREATEMUTEX,
    pub DestroyMutex: CK_DESTROYMUTEX,
    pub LockMutex: CK_LOCKMUTEX,
    pub UnlockMutex: CK_UNLOCKMUTEX,
    pub flags: CK_FLAGS,
    pub pReserved: CK_VOID_PTR,
}
#[test]
fn bindgen_test_layout_CK_C_INITIALIZE_ARGS() {
    assert_eq!(
        ::std::mem::size_of::<CK_C_INITIALIZE_ARGS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_C_INITIALIZE_ARGS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_C_INITIALIZE_ARGS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_C_INITIALIZE_ARGS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_C_INITIALIZE_ARGS>())).CreateMutex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_C_INITIALIZE_ARGS),
            "::",
            stringify!(CreateMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_C_INITIALIZE_ARGS>())).DestroyMutex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_C_INITIALIZE_ARGS),
            "::",
            stringify!(DestroyMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_C_INITIALIZE_ARGS>())).LockMutex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_C_INITIALIZE_ARGS),
            "::",
            stringify!(LockMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_C_INITIALIZE_ARGS>())).UnlockMutex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_C_INITIALIZE_ARGS),
            "::",
            stringify!(UnlockMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_C_INITIALIZE_ARGS>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_C_INITIALIZE_ARGS),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_C_INITIALIZE_ARGS>())).pReserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_C_INITIALIZE_ARGS),
            "::",
            stringify!(pReserved)
        )
    );
}
impl Default for CK_C_INITIALIZE_ARGS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_C_INITIALIZE_ARGS_PTR = *mut CK_C_INITIALIZE_ARGS;
pub type CK_RSA_PKCS_MGF_TYPE = CK_ULONG;
pub type CK_RSA_PKCS_MGF_TYPE_PTR = *mut CK_RSA_PKCS_MGF_TYPE;
pub type CK_RSA_PKCS_OAEP_SOURCE_TYPE = CK_ULONG;
pub type CK_RSA_PKCS_OAEP_SOURCE_TYPE_PTR = *mut CK_RSA_PKCS_OAEP_SOURCE_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_RSA_PKCS_OAEP_PARAMS {
    pub hashAlg: CK_MECHANISM_TYPE,
    pub mgf: CK_RSA_PKCS_MGF_TYPE,
    pub source: CK_RSA_PKCS_OAEP_SOURCE_TYPE,
    pub pSourceData: CK_VOID_PTR,
    pub ulSourceDataLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_RSA_PKCS_OAEP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RSA_PKCS_OAEP_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_RSA_PKCS_OAEP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RSA_PKCS_OAEP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RSA_PKCS_OAEP_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RSA_PKCS_OAEP_PARAMS>())).hashAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_OAEP_PARAMS),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RSA_PKCS_OAEP_PARAMS>())).mgf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_OAEP_PARAMS),
            "::",
            stringify!(mgf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RSA_PKCS_OAEP_PARAMS>())).source as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_OAEP_PARAMS),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RSA_PKCS_OAEP_PARAMS>())).pSourceData as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_OAEP_PARAMS),
            "::",
            stringify!(pSourceData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RSA_PKCS_OAEP_PARAMS>())).ulSourceDataLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_OAEP_PARAMS),
            "::",
            stringify!(ulSourceDataLen)
        )
    );
}
impl Default for CK_RSA_PKCS_OAEP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_RSA_PKCS_OAEP_PARAMS_PTR = *mut CK_RSA_PKCS_OAEP_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_RSA_PKCS_PSS_PARAMS {
    pub hashAlg: CK_MECHANISM_TYPE,
    pub mgf: CK_RSA_PKCS_MGF_TYPE,
    pub sLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_RSA_PKCS_PSS_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RSA_PKCS_PSS_PARAMS>(),
        12usize,
        concat!("Size of: ", stringify!(CK_RSA_PKCS_PSS_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RSA_PKCS_PSS_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RSA_PKCS_PSS_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RSA_PKCS_PSS_PARAMS>())).hashAlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_PSS_PARAMS),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RSA_PKCS_PSS_PARAMS>())).mgf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_PSS_PARAMS),
            "::",
            stringify!(mgf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RSA_PKCS_PSS_PARAMS>())).sLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_PKCS_PSS_PARAMS),
            "::",
            stringify!(sLen)
        )
    );
}
pub type CK_RSA_PKCS_PSS_PARAMS_PTR = *mut CK_RSA_PKCS_PSS_PARAMS;
pub type CK_EC_KDF_TYPE = CK_ULONG;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_ECDH1_DERIVE_PARAMS {
    pub kdf: CK_EC_KDF_TYPE,
    pub ulSharedDataLen: CK_ULONG,
    pub pSharedData: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_ECDH1_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_ECDH1_DERIVE_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_ECDH1_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_ECDH1_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_ECDH1_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_ECDH1_DERIVE_PARAMS>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH1_DERIVE_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH1_DERIVE_PARAMS>())).ulSharedDataLen as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH1_DERIVE_PARAMS),
            "::",
            stringify!(ulSharedDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH1_DERIVE_PARAMS>())).pSharedData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH1_DERIVE_PARAMS),
            "::",
            stringify!(pSharedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH1_DERIVE_PARAMS>())).ulPublicDataLen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH1_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH1_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH1_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
}
impl Default for CK_ECDH1_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_ECDH1_DERIVE_PARAMS_PTR = *mut CK_ECDH1_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_ECDH2_DERIVE_PARAMS {
    pub kdf: CK_EC_KDF_TYPE,
    pub ulSharedDataLen: CK_ULONG,
    pub pSharedData: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_ECDH2_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_ECDH2_DERIVE_PARAMS>(),
        36usize,
        concat!("Size of: ", stringify!(CK_ECDH2_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_ECDH2_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_ECDH2_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).ulSharedDataLen as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(ulSharedDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).pSharedData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(pSharedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).ulPublicDataLen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).ulPrivateDataLen as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(ulPrivateDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).hPrivateData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(hPrivateData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).ulPublicDataLen2 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH2_DERIVE_PARAMS>())).pPublicData2 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH2_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData2)
        )
    );
}
impl Default for CK_ECDH2_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_ECDH2_DERIVE_PARAMS_PTR = *mut CK_ECDH2_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_ECMQV_DERIVE_PARAMS {
    pub kdf: CK_EC_KDF_TYPE,
    pub ulSharedDataLen: CK_ULONG,
    pub pSharedData: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
    pub publicKey: CK_OBJECT_HANDLE,
}
#[test]
fn bindgen_test_layout_CK_ECMQV_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_ECMQV_DERIVE_PARAMS>(),
        40usize,
        concat!("Size of: ", stringify!(CK_ECMQV_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_ECMQV_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_ECMQV_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).ulSharedDataLen as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(ulSharedDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).pSharedData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(pSharedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).ulPublicDataLen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).ulPrivateDataLen as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(ulPrivateDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).hPrivateData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(hPrivateData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).ulPublicDataLen2 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).pPublicData2 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECMQV_DERIVE_PARAMS>())).publicKey as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECMQV_DERIVE_PARAMS),
            "::",
            stringify!(publicKey)
        )
    );
}
impl Default for CK_ECMQV_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_ECMQV_DERIVE_PARAMS_PTR = *mut CK_ECMQV_DERIVE_PARAMS;
pub type CK_X9_42_DH_KDF_TYPE = CK_ULONG;
pub type CK_X9_42_DH_KDF_TYPE_PTR = *mut CK_X9_42_DH_KDF_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_X9_42_DH1_DERIVE_PARAMS {
    pub kdf: CK_X9_42_DH_KDF_TYPE,
    pub ulOtherInfoLen: CK_ULONG,
    pub pOtherInfo: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_X9_42_DH1_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_X9_42_DH1_DERIVE_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_X9_42_DH1_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_X9_42_DH1_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_X9_42_DH1_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_X9_42_DH1_DERIVE_PARAMS>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH1_DERIVE_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH1_DERIVE_PARAMS>())).ulOtherInfoLen as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH1_DERIVE_PARAMS),
            "::",
            stringify!(ulOtherInfoLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH1_DERIVE_PARAMS>())).pOtherInfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH1_DERIVE_PARAMS),
            "::",
            stringify!(pOtherInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH1_DERIVE_PARAMS>())).ulPublicDataLen as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH1_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH1_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH1_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
}
impl Default for CK_X9_42_DH1_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_X9_42_DH1_DERIVE_PARAMS_PTR = *mut CK_X9_42_DH1_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_X9_42_DH2_DERIVE_PARAMS {
    pub kdf: CK_X9_42_DH_KDF_TYPE,
    pub ulOtherInfoLen: CK_ULONG,
    pub pOtherInfo: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_X9_42_DH2_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_X9_42_DH2_DERIVE_PARAMS>(),
        36usize,
        concat!("Size of: ", stringify!(CK_X9_42_DH2_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_X9_42_DH2_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_X9_42_DH2_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).ulOtherInfoLen as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(ulOtherInfoLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).pOtherInfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(pOtherInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).ulPublicDataLen as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).ulPrivateDataLen as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(ulPrivateDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).hPrivateData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(hPrivateData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).ulPublicDataLen2 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_DH2_DERIVE_PARAMS>())).pPublicData2 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_DH2_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData2)
        )
    );
}
impl Default for CK_X9_42_DH2_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_X9_42_DH2_DERIVE_PARAMS_PTR = *mut CK_X9_42_DH2_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_X9_42_MQV_DERIVE_PARAMS {
    pub kdf: CK_X9_42_DH_KDF_TYPE,
    pub ulOtherInfoLen: CK_ULONG,
    pub pOtherInfo: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
    pub publicKey: CK_OBJECT_HANDLE,
}
#[test]
fn bindgen_test_layout_CK_X9_42_MQV_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_X9_42_MQV_DERIVE_PARAMS>(),
        40usize,
        concat!("Size of: ", stringify!(CK_X9_42_MQV_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_X9_42_MQV_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_X9_42_MQV_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).ulOtherInfoLen as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(ulOtherInfoLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).pOtherInfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(pOtherInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).ulPublicDataLen as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).ulPrivateDataLen as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(ulPrivateDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).hPrivateData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(hPrivateData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).ulPublicDataLen2 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).pPublicData2 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_X9_42_MQV_DERIVE_PARAMS>())).publicKey as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_X9_42_MQV_DERIVE_PARAMS),
            "::",
            stringify!(publicKey)
        )
    );
}
impl Default for CK_X9_42_MQV_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_X9_42_MQV_DERIVE_PARAMS_PTR = *mut CK_X9_42_MQV_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_KEA_DERIVE_PARAMS {
    pub isSender: CK_BBOOL,
    pub ulRandomLen: CK_ULONG,
    pub pRandomA: CK_BYTE_PTR,
    pub pRandomB: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_KEA_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_KEA_DERIVE_PARAMS>(),
        21usize,
        concat!("Size of: ", stringify!(CK_KEA_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_KEA_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_KEA_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KEA_DERIVE_PARAMS>())).isSender as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEA_DERIVE_PARAMS),
            "::",
            stringify!(isSender)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_KEA_DERIVE_PARAMS>())).ulRandomLen as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEA_DERIVE_PARAMS),
            "::",
            stringify!(ulRandomLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KEA_DERIVE_PARAMS>())).pRandomA as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEA_DERIVE_PARAMS),
            "::",
            stringify!(pRandomA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KEA_DERIVE_PARAMS>())).pRandomB as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEA_DERIVE_PARAMS),
            "::",
            stringify!(pRandomB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_KEA_DERIVE_PARAMS>())).ulPublicDataLen as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEA_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_KEA_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEA_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
}
impl Default for CK_KEA_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_KEA_DERIVE_PARAMS_PTR = *mut CK_KEA_DERIVE_PARAMS;
pub type CK_RC2_PARAMS = CK_ULONG;
pub type CK_RC2_PARAMS_PTR = *mut CK_RC2_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_RC2_CBC_PARAMS {
    pub ulEffectiveBits: CK_ULONG,
    pub iv: [CK_BYTE; 8usize],
}
#[test]
fn bindgen_test_layout_CK_RC2_CBC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RC2_CBC_PARAMS>(),
        12usize,
        concat!("Size of: ", stringify!(CK_RC2_CBC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RC2_CBC_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RC2_CBC_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RC2_CBC_PARAMS>())).ulEffectiveBits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC2_CBC_PARAMS),
            "::",
            stringify!(ulEffectiveBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RC2_CBC_PARAMS>())).iv as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC2_CBC_PARAMS),
            "::",
            stringify!(iv)
        )
    );
}
pub type CK_RC2_CBC_PARAMS_PTR = *mut CK_RC2_CBC_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_RC2_MAC_GENERAL_PARAMS {
    pub ulEffectiveBits: CK_ULONG,
    pub ulMacLength: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_RC2_MAC_GENERAL_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RC2_MAC_GENERAL_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(CK_RC2_MAC_GENERAL_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RC2_MAC_GENERAL_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RC2_MAC_GENERAL_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RC2_MAC_GENERAL_PARAMS>())).ulEffectiveBits as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC2_MAC_GENERAL_PARAMS),
            "::",
            stringify!(ulEffectiveBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RC2_MAC_GENERAL_PARAMS>())).ulMacLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC2_MAC_GENERAL_PARAMS),
            "::",
            stringify!(ulMacLength)
        )
    );
}
pub type CK_RC2_MAC_GENERAL_PARAMS_PTR = *mut CK_RC2_MAC_GENERAL_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_RC5_PARAMS {
    pub ulWordsize: CK_ULONG,
    pub ulRounds: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_RC5_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RC5_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(CK_RC5_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RC5_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RC5_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RC5_PARAMS>())).ulWordsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_PARAMS),
            "::",
            stringify!(ulWordsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RC5_PARAMS>())).ulRounds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_PARAMS),
            "::",
            stringify!(ulRounds)
        )
    );
}
pub type CK_RC5_PARAMS_PTR = *mut CK_RC5_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_RC5_CBC_PARAMS {
    pub ulWordsize: CK_ULONG,
    pub ulRounds: CK_ULONG,
    pub pIv: CK_BYTE_PTR,
    pub ulIvLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_RC5_CBC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RC5_CBC_PARAMS>(),
        16usize,
        concat!("Size of: ", stringify!(CK_RC5_CBC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RC5_CBC_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RC5_CBC_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RC5_CBC_PARAMS>())).ulWordsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_CBC_PARAMS),
            "::",
            stringify!(ulWordsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RC5_CBC_PARAMS>())).ulRounds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_CBC_PARAMS),
            "::",
            stringify!(ulRounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RC5_CBC_PARAMS>())).pIv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_CBC_PARAMS),
            "::",
            stringify!(pIv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_RC5_CBC_PARAMS>())).ulIvLen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_CBC_PARAMS),
            "::",
            stringify!(ulIvLen)
        )
    );
}
impl Default for CK_RC5_CBC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_RC5_CBC_PARAMS_PTR = *mut CK_RC5_CBC_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_RC5_MAC_GENERAL_PARAMS {
    pub ulWordsize: CK_ULONG,
    pub ulRounds: CK_ULONG,
    pub ulMacLength: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_RC5_MAC_GENERAL_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RC5_MAC_GENERAL_PARAMS>(),
        12usize,
        concat!("Size of: ", stringify!(CK_RC5_MAC_GENERAL_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RC5_MAC_GENERAL_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RC5_MAC_GENERAL_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RC5_MAC_GENERAL_PARAMS>())).ulWordsize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_MAC_GENERAL_PARAMS),
            "::",
            stringify!(ulWordsize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RC5_MAC_GENERAL_PARAMS>())).ulRounds as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_MAC_GENERAL_PARAMS),
            "::",
            stringify!(ulRounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RC5_MAC_GENERAL_PARAMS>())).ulMacLength as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RC5_MAC_GENERAL_PARAMS),
            "::",
            stringify!(ulMacLength)
        )
    );
}
pub type CK_RC5_MAC_GENERAL_PARAMS_PTR = *mut CK_RC5_MAC_GENERAL_PARAMS;
pub type CK_MAC_GENERAL_PARAMS = CK_ULONG;
pub type CK_MAC_GENERAL_PARAMS_PTR = *mut CK_MAC_GENERAL_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_DES_CBC_ENCRYPT_DATA_PARAMS {
    pub iv: [CK_BYTE; 8usize],
    pub pData: CK_BYTE_PTR,
    pub length: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_DES_CBC_ENCRYPT_DATA_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_DES_CBC_ENCRYPT_DATA_PARAMS>(),
        16usize,
        concat!("Size of: ", stringify!(CK_DES_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_DES_CBC_ENCRYPT_DATA_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_DES_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_DES_CBC_ENCRYPT_DATA_PARAMS>())).iv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DES_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_DES_CBC_ENCRYPT_DATA_PARAMS>())).pData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DES_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_DES_CBC_ENCRYPT_DATA_PARAMS>())).length as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DES_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(length)
        )
    );
}
impl Default for CK_DES_CBC_ENCRYPT_DATA_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR = *mut CK_DES_CBC_ENCRYPT_DATA_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_AES_CBC_ENCRYPT_DATA_PARAMS {
    pub iv: [CK_BYTE; 16usize],
    pub pData: CK_BYTE_PTR,
    pub length: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_AES_CBC_ENCRYPT_DATA_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_AES_CBC_ENCRYPT_DATA_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_AES_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_AES_CBC_ENCRYPT_DATA_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_AES_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_AES_CBC_ENCRYPT_DATA_PARAMS>())).iv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_AES_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_AES_CBC_ENCRYPT_DATA_PARAMS>())).pData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_AES_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_AES_CBC_ENCRYPT_DATA_PARAMS>())).length as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_AES_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(length)
        )
    );
}
impl Default for CK_AES_CBC_ENCRYPT_DATA_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR = *mut CK_AES_CBC_ENCRYPT_DATA_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SKIPJACK_PRIVATE_WRAP_PARAMS {
    pub ulPasswordLen: CK_ULONG,
    pub pPassword: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPAndGLen: CK_ULONG,
    pub ulQLen: CK_ULONG,
    pub ulRandomLen: CK_ULONG,
    pub pRandomA: CK_BYTE_PTR,
    pub pPrimeP: CK_BYTE_PTR,
    pub pBaseG: CK_BYTE_PTR,
    pub pSubprimeQ: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_SKIPJACK_PRIVATE_WRAP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>(),
        44usize,
        concat!("Size of: ", stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).ulPasswordLen as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(ulPasswordLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).pPassword as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(pPassword)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).ulPublicDataLen as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).pPublicData as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).ulPAndGLen as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(ulPAndGLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).ulQLen as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(ulQLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).ulRandomLen as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(ulRandomLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).pRandomA as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(pRandomA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).pPrimeP as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(pPrimeP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).pBaseG as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(pBaseG)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_PRIVATE_WRAP_PARAMS>())).pSubprimeQ as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_PRIVATE_WRAP_PARAMS),
            "::",
            stringify!(pSubprimeQ)
        )
    );
}
impl Default for CK_SKIPJACK_PRIVATE_WRAP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_SKIPJACK_PRIVATE_WRAP_PARAMS_PTR = *mut CK_SKIPJACK_PRIVATE_WRAP_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SKIPJACK_RELAYX_PARAMS {
    pub ulOldWrappedXLen: CK_ULONG,
    pub pOldWrappedX: CK_BYTE_PTR,
    pub ulOldPasswordLen: CK_ULONG,
    pub pOldPassword: CK_BYTE_PTR,
    pub ulOldPublicDataLen: CK_ULONG,
    pub pOldPublicData: CK_BYTE_PTR,
    pub ulOldRandomLen: CK_ULONG,
    pub pOldRandomA: CK_BYTE_PTR,
    pub ulNewPasswordLen: CK_ULONG,
    pub pNewPassword: CK_BYTE_PTR,
    pub ulNewPublicDataLen: CK_ULONG,
    pub pNewPublicData: CK_BYTE_PTR,
    pub ulNewRandomLen: CK_ULONG,
    pub pNewRandomA: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_SKIPJACK_RELAYX_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_SKIPJACK_RELAYX_PARAMS>(),
        56usize,
        concat!("Size of: ", stringify!(CK_SKIPJACK_RELAYX_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SKIPJACK_RELAYX_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SKIPJACK_RELAYX_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).ulOldWrappedXLen as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(ulOldWrappedXLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).pOldWrappedX as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(pOldWrappedX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).ulOldPasswordLen as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(ulOldPasswordLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).pOldPassword as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(pOldPassword)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).ulOldPublicDataLen as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(ulOldPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).pOldPublicData as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(pOldPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).ulOldRandomLen as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(ulOldRandomLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).pOldRandomA as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(pOldRandomA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).ulNewPasswordLen as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(ulNewPasswordLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).pNewPassword as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(pNewPassword)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).ulNewPublicDataLen as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(ulNewPublicDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).pNewPublicData as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(pNewPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).ulNewRandomLen as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(ulNewRandomLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SKIPJACK_RELAYX_PARAMS>())).pNewRandomA as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SKIPJACK_RELAYX_PARAMS),
            "::",
            stringify!(pNewRandomA)
        )
    );
}
impl Default for CK_SKIPJACK_RELAYX_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_SKIPJACK_RELAYX_PARAMS_PTR = *mut CK_SKIPJACK_RELAYX_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_PBE_PARAMS {
    pub pInitVector: CK_BYTE_PTR,
    pub pPassword: CK_UTF8CHAR_PTR,
    pub ulPasswordLen: CK_ULONG,
    pub pSalt: CK_BYTE_PTR,
    pub ulSaltLen: CK_ULONG,
    pub ulIteration: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_PBE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_PBE_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_PBE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_PBE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_PBE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PBE_PARAMS>())).pInitVector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PBE_PARAMS),
            "::",
            stringify!(pInitVector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PBE_PARAMS>())).pPassword as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PBE_PARAMS),
            "::",
            stringify!(pPassword)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PBE_PARAMS>())).ulPasswordLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PBE_PARAMS),
            "::",
            stringify!(ulPasswordLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PBE_PARAMS>())).pSalt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PBE_PARAMS),
            "::",
            stringify!(pSalt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PBE_PARAMS>())).ulSaltLen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PBE_PARAMS),
            "::",
            stringify!(ulSaltLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PBE_PARAMS>())).ulIteration as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PBE_PARAMS),
            "::",
            stringify!(ulIteration)
        )
    );
}
impl Default for CK_PBE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_PBE_PARAMS_PTR = *mut CK_PBE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_KEY_WRAP_SET_OAEP_PARAMS {
    pub bBC: CK_BYTE,
    pub pX: CK_BYTE_PTR,
    pub ulXLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_KEY_WRAP_SET_OAEP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_KEY_WRAP_SET_OAEP_PARAMS>(),
        9usize,
        concat!("Size of: ", stringify!(CK_KEY_WRAP_SET_OAEP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_KEY_WRAP_SET_OAEP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_KEY_WRAP_SET_OAEP_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KEY_WRAP_SET_OAEP_PARAMS>())).bBC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEY_WRAP_SET_OAEP_PARAMS),
            "::",
            stringify!(bBC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KEY_WRAP_SET_OAEP_PARAMS>())).pX as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEY_WRAP_SET_OAEP_PARAMS),
            "::",
            stringify!(pX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_KEY_WRAP_SET_OAEP_PARAMS>())).ulXLen as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEY_WRAP_SET_OAEP_PARAMS),
            "::",
            stringify!(ulXLen)
        )
    );
}
impl Default for CK_KEY_WRAP_SET_OAEP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_KEY_WRAP_SET_OAEP_PARAMS_PTR = *mut CK_KEY_WRAP_SET_OAEP_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SSL3_RANDOM_DATA {
    pub pClientRandom: CK_BYTE_PTR,
    pub ulClientRandomLen: CK_ULONG,
    pub pServerRandom: CK_BYTE_PTR,
    pub ulServerRandomLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_SSL3_RANDOM_DATA() {
    assert_eq!(
        ::std::mem::size_of::<CK_SSL3_RANDOM_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(CK_SSL3_RANDOM_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SSL3_RANDOM_DATA>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SSL3_RANDOM_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_RANDOM_DATA>())).pClientRandom as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_RANDOM_DATA),
            "::",
            stringify!(pClientRandom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_RANDOM_DATA>())).ulClientRandomLen as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_RANDOM_DATA),
            "::",
            stringify!(ulClientRandomLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_RANDOM_DATA>())).pServerRandom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_RANDOM_DATA),
            "::",
            stringify!(pServerRandom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_RANDOM_DATA>())).ulServerRandomLen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_RANDOM_DATA),
            "::",
            stringify!(ulServerRandomLen)
        )
    );
}
impl Default for CK_SSL3_RANDOM_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS {
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pVersion: CK_VERSION_PTR,
}
#[test]
fn bindgen_test_layout_CK_SSL3_MASTER_KEY_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_SSL3_MASTER_KEY_DERIVE_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_SSL3_MASTER_KEY_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SSL3_MASTER_KEY_DERIVE_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CK_SSL3_MASTER_KEY_DERIVE_PARAMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_MASTER_KEY_DERIVE_PARAMS>())).RandomInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(RandomInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_MASTER_KEY_DERIVE_PARAMS>())).pVersion as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(pVersion)
        )
    );
}
impl Default for CK_SSL3_MASTER_KEY_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR = *mut CK_SSL3_MASTER_KEY_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SSL3_KEY_MAT_OUT {
    pub hClientMacSecret: CK_OBJECT_HANDLE,
    pub hServerMacSecret: CK_OBJECT_HANDLE,
    pub hClientKey: CK_OBJECT_HANDLE,
    pub hServerKey: CK_OBJECT_HANDLE,
    pub pIVClient: CK_BYTE_PTR,
    pub pIVServer: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_SSL3_KEY_MAT_OUT() {
    assert_eq!(
        ::std::mem::size_of::<CK_SSL3_KEY_MAT_OUT>(),
        24usize,
        concat!("Size of: ", stringify!(CK_SSL3_KEY_MAT_OUT))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SSL3_KEY_MAT_OUT>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SSL3_KEY_MAT_OUT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_OUT>())).hClientMacSecret as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_OUT),
            "::",
            stringify!(hClientMacSecret)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_OUT>())).hServerMacSecret as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_OUT),
            "::",
            stringify!(hServerMacSecret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_OUT>())).hClientKey as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_OUT),
            "::",
            stringify!(hClientKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_OUT>())).hServerKey as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_OUT),
            "::",
            stringify!(hServerKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_OUT>())).pIVClient as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_OUT),
            "::",
            stringify!(pIVClient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_OUT>())).pIVServer as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_OUT),
            "::",
            stringify!(pIVServer)
        )
    );
}
impl Default for CK_SSL3_KEY_MAT_OUT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_SSL3_KEY_MAT_OUT_PTR = *mut CK_SSL3_KEY_MAT_OUT;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SSL3_KEY_MAT_PARAMS {
    pub ulMacSizeInBits: CK_ULONG,
    pub ulKeySizeInBits: CK_ULONG,
    pub ulIVSizeInBits: CK_ULONG,
    pub bIsExport: CK_BBOOL,
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pReturnedKeyMaterial: CK_SSL3_KEY_MAT_OUT_PTR,
}
#[test]
fn bindgen_test_layout_CK_SSL3_KEY_MAT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_SSL3_KEY_MAT_PARAMS>(),
        33usize,
        concat!("Size of: ", stringify!(CK_SSL3_KEY_MAT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SSL3_KEY_MAT_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SSL3_KEY_MAT_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_PARAMS>())).ulMacSizeInBits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_PARAMS),
            "::",
            stringify!(ulMacSizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_PARAMS>())).ulKeySizeInBits as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_PARAMS),
            "::",
            stringify!(ulKeySizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_PARAMS>())).ulIVSizeInBits as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_PARAMS),
            "::",
            stringify!(ulIVSizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_PARAMS>())).bIsExport as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_PARAMS),
            "::",
            stringify!(bIsExport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_PARAMS>())).RandomInfo as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_PARAMS),
            "::",
            stringify!(RandomInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SSL3_KEY_MAT_PARAMS>())).pReturnedKeyMaterial as *const _
                as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SSL3_KEY_MAT_PARAMS),
            "::",
            stringify!(pReturnedKeyMaterial)
        )
    );
}
impl Default for CK_SSL3_KEY_MAT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_SSL3_KEY_MAT_PARAMS_PTR = *mut CK_SSL3_KEY_MAT_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_TLS_PRF_PARAMS {
    pub pSeed: CK_BYTE_PTR,
    pub ulSeedLen: CK_ULONG,
    pub pLabel: CK_BYTE_PTR,
    pub ulLabelLen: CK_ULONG,
    pub pOutput: CK_BYTE_PTR,
    pub pulOutputLen: CK_ULONG_PTR,
}
#[test]
fn bindgen_test_layout_CK_TLS_PRF_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_TLS_PRF_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_TLS_PRF_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_TLS_PRF_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_TLS_PRF_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_PRF_PARAMS>())).pSeed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_PRF_PARAMS),
            "::",
            stringify!(pSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_PRF_PARAMS>())).ulSeedLen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_PRF_PARAMS),
            "::",
            stringify!(ulSeedLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_PRF_PARAMS>())).pLabel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_PRF_PARAMS),
            "::",
            stringify!(pLabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_PRF_PARAMS>())).ulLabelLen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_PRF_PARAMS),
            "::",
            stringify!(ulLabelLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_PRF_PARAMS>())).pOutput as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_PRF_PARAMS),
            "::",
            stringify!(pOutput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_PRF_PARAMS>())).pulOutputLen as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_PRF_PARAMS),
            "::",
            stringify!(pulOutputLen)
        )
    );
}
impl Default for CK_TLS_PRF_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_TLS_PRF_PARAMS_PTR = *mut CK_TLS_PRF_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_WTLS_RANDOM_DATA {
    pub pClientRandom: CK_BYTE_PTR,
    pub ulClientRandomLen: CK_ULONG,
    pub pServerRandom: CK_BYTE_PTR,
    pub ulServerRandomLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_WTLS_RANDOM_DATA() {
    assert_eq!(
        ::std::mem::size_of::<CK_WTLS_RANDOM_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(CK_WTLS_RANDOM_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_WTLS_RANDOM_DATA>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_WTLS_RANDOM_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_RANDOM_DATA>())).pClientRandom as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_RANDOM_DATA),
            "::",
            stringify!(pClientRandom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_RANDOM_DATA>())).ulClientRandomLen as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_RANDOM_DATA),
            "::",
            stringify!(ulClientRandomLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_RANDOM_DATA>())).pServerRandom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_RANDOM_DATA),
            "::",
            stringify!(pServerRandom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_RANDOM_DATA>())).ulServerRandomLen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_RANDOM_DATA),
            "::",
            stringify!(ulServerRandomLen)
        )
    );
}
impl Default for CK_WTLS_RANDOM_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_WTLS_RANDOM_DATA_PTR = *mut CK_WTLS_RANDOM_DATA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_WTLS_MASTER_KEY_DERIVE_PARAMS {
    pub DigestMechanism: CK_MECHANISM_TYPE,
    pub RandomInfo: CK_WTLS_RANDOM_DATA,
    pub pVersion: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_WTLS_MASTER_KEY_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_WTLS_MASTER_KEY_DERIVE_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_WTLS_MASTER_KEY_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_WTLS_MASTER_KEY_DERIVE_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CK_WTLS_MASTER_KEY_DERIVE_PARAMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_MASTER_KEY_DERIVE_PARAMS>())).DigestMechanism as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(DigestMechanism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_MASTER_KEY_DERIVE_PARAMS>())).RandomInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(RandomInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_MASTER_KEY_DERIVE_PARAMS>())).pVersion as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(pVersion)
        )
    );
}
impl Default for CK_WTLS_MASTER_KEY_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_WTLS_MASTER_KEY_DERIVE_PARAMS_PTR = *mut CK_WTLS_MASTER_KEY_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_WTLS_PRF_PARAMS {
    pub DigestMechanism: CK_MECHANISM_TYPE,
    pub pSeed: CK_BYTE_PTR,
    pub ulSeedLen: CK_ULONG,
    pub pLabel: CK_BYTE_PTR,
    pub ulLabelLen: CK_ULONG,
    pub pOutput: CK_BYTE_PTR,
    pub pulOutputLen: CK_ULONG_PTR,
}
#[test]
fn bindgen_test_layout_CK_WTLS_PRF_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_WTLS_PRF_PARAMS>(),
        28usize,
        concat!("Size of: ", stringify!(CK_WTLS_PRF_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_WTLS_PRF_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_WTLS_PRF_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_PRF_PARAMS>())).DigestMechanism as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_PRF_PARAMS),
            "::",
            stringify!(DigestMechanism)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_PRF_PARAMS>())).pSeed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_PRF_PARAMS),
            "::",
            stringify!(pSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_PRF_PARAMS>())).ulSeedLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_PRF_PARAMS),
            "::",
            stringify!(ulSeedLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_PRF_PARAMS>())).pLabel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_PRF_PARAMS),
            "::",
            stringify!(pLabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_PRF_PARAMS>())).ulLabelLen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_PRF_PARAMS),
            "::",
            stringify!(ulLabelLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_PRF_PARAMS>())).pOutput as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_PRF_PARAMS),
            "::",
            stringify!(pOutput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_PRF_PARAMS>())).pulOutputLen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_PRF_PARAMS),
            "::",
            stringify!(pulOutputLen)
        )
    );
}
impl Default for CK_WTLS_PRF_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_WTLS_PRF_PARAMS_PTR = *mut CK_WTLS_PRF_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_WTLS_KEY_MAT_OUT {
    pub hMacSecret: CK_OBJECT_HANDLE,
    pub hKey: CK_OBJECT_HANDLE,
    pub pIV: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_WTLS_KEY_MAT_OUT() {
    assert_eq!(
        ::std::mem::size_of::<CK_WTLS_KEY_MAT_OUT>(),
        12usize,
        concat!("Size of: ", stringify!(CK_WTLS_KEY_MAT_OUT))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_WTLS_KEY_MAT_OUT>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_WTLS_KEY_MAT_OUT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_OUT>())).hMacSecret as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_OUT),
            "::",
            stringify!(hMacSecret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_OUT>())).hKey as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_OUT),
            "::",
            stringify!(hKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_OUT>())).pIV as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_OUT),
            "::",
            stringify!(pIV)
        )
    );
}
impl Default for CK_WTLS_KEY_MAT_OUT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_WTLS_KEY_MAT_OUT_PTR = *mut CK_WTLS_KEY_MAT_OUT;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_WTLS_KEY_MAT_PARAMS {
    pub DigestMechanism: CK_MECHANISM_TYPE,
    pub ulMacSizeInBits: CK_ULONG,
    pub ulKeySizeInBits: CK_ULONG,
    pub ulIVSizeInBits: CK_ULONG,
    pub ulSequenceNumber: CK_ULONG,
    pub bIsExport: CK_BBOOL,
    pub RandomInfo: CK_WTLS_RANDOM_DATA,
    pub pReturnedKeyMaterial: CK_WTLS_KEY_MAT_OUT_PTR,
}
#[test]
fn bindgen_test_layout_CK_WTLS_KEY_MAT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_WTLS_KEY_MAT_PARAMS>(),
        41usize,
        concat!("Size of: ", stringify!(CK_WTLS_KEY_MAT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_WTLS_KEY_MAT_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_WTLS_KEY_MAT_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).DigestMechanism as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(DigestMechanism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).ulMacSizeInBits as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(ulMacSizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).ulKeySizeInBits as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(ulKeySizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).ulIVSizeInBits as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(ulIVSizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).ulSequenceNumber as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(ulSequenceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).bIsExport as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(bIsExport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).RandomInfo as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(RandomInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_WTLS_KEY_MAT_PARAMS>())).pReturnedKeyMaterial as *const _
                as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_WTLS_KEY_MAT_PARAMS),
            "::",
            stringify!(pReturnedKeyMaterial)
        )
    );
}
impl Default for CK_WTLS_KEY_MAT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_WTLS_KEY_MAT_PARAMS_PTR = *mut CK_WTLS_KEY_MAT_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_CMS_SIG_PARAMS {
    pub certificateHandle: CK_OBJECT_HANDLE,
    pub pSigningMechanism: CK_MECHANISM_PTR,
    pub pDigestMechanism: CK_MECHANISM_PTR,
    pub pContentType: CK_UTF8CHAR_PTR,
    pub pRequestedAttributes: CK_BYTE_PTR,
    pub ulRequestedAttributesLen: CK_ULONG,
    pub pRequiredAttributes: CK_BYTE_PTR,
    pub ulRequiredAttributesLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_CMS_SIG_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_CMS_SIG_PARAMS>(),
        32usize,
        concat!("Size of: ", stringify!(CK_CMS_SIG_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_CMS_SIG_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_CMS_SIG_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).certificateHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(certificateHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).pSigningMechanism as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(pSigningMechanism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).pDigestMechanism as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(pDigestMechanism)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).pContentType as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(pContentType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).pRequestedAttributes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(pRequestedAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).ulRequestedAttributesLen as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(ulRequestedAttributesLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).pRequiredAttributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(pRequiredAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CMS_SIG_PARAMS>())).ulRequiredAttributesLen as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CMS_SIG_PARAMS),
            "::",
            stringify!(ulRequiredAttributesLen)
        )
    );
}
impl Default for CK_CMS_SIG_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_CMS_SIG_PARAMS_PTR = *mut CK_CMS_SIG_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_KEY_DERIVATION_STRING_DATA {
    pub pData: CK_BYTE_PTR,
    pub ulLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_KEY_DERIVATION_STRING_DATA() {
    assert_eq!(
        ::std::mem::size_of::<CK_KEY_DERIVATION_STRING_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(CK_KEY_DERIVATION_STRING_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_KEY_DERIVATION_STRING_DATA>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_KEY_DERIVATION_STRING_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_KEY_DERIVATION_STRING_DATA>())).pData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEY_DERIVATION_STRING_DATA),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_KEY_DERIVATION_STRING_DATA>())).ulLen as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KEY_DERIVATION_STRING_DATA),
            "::",
            stringify!(ulLen)
        )
    );
}
impl Default for CK_KEY_DERIVATION_STRING_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_KEY_DERIVATION_STRING_DATA_PTR = *mut CK_KEY_DERIVATION_STRING_DATA;
pub type CK_EXTRACT_PARAMS = CK_ULONG;
pub type CK_EXTRACT_PARAMS_PTR = *mut CK_EXTRACT_PARAMS;
pub type CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE = CK_ULONG;
pub type CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE_PTR =
    *mut CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE;
pub type CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE = CK_ULONG;
pub type CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE_PTR = *mut CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_PKCS5_PBKD2_PARAMS {
    pub saltSource: CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE,
    pub pSaltSourceData: CK_VOID_PTR,
    pub ulSaltSourceDataLen: CK_ULONG,
    pub iterations: CK_ULONG,
    pub prf: CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE,
    pub pPrfData: CK_VOID_PTR,
    pub ulPrfDataLen: CK_ULONG,
    pub pPassword: CK_UTF8CHAR_PTR,
    pub ulPasswordLen: CK_ULONG_PTR,
}
#[test]
fn bindgen_test_layout_CK_PKCS5_PBKD2_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_PKCS5_PBKD2_PARAMS>(),
        36usize,
        concat!("Size of: ", stringify!(CK_PKCS5_PBKD2_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_PKCS5_PBKD2_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_PKCS5_PBKD2_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).saltSource as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(saltSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).pSaltSourceData as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(pSaltSourceData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).ulSaltSourceDataLen as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(ulSaltSourceDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).iterations as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(iterations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).prf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(prf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).pPrfData as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(pPrfData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).ulPrfDataLen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(ulPrfDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).pPassword as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(pPassword)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS>())).ulPasswordLen as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS),
            "::",
            stringify!(ulPasswordLen)
        )
    );
}
impl Default for CK_PKCS5_PBKD2_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_PKCS5_PBKD2_PARAMS_PTR = *mut CK_PKCS5_PBKD2_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_PKCS5_PBKD2_PARAMS2 {
    pub saltSource: CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE,
    pub pSaltSourceData: CK_VOID_PTR,
    pub ulSaltSourceDataLen: CK_ULONG,
    pub iterations: CK_ULONG,
    pub prf: CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE,
    pub pPrfData: CK_VOID_PTR,
    pub ulPrfDataLen: CK_ULONG,
    pub pPassword: CK_UTF8CHAR_PTR,
    pub ulPasswordLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_PKCS5_PBKD2_PARAMS2() {
    assert_eq!(
        ::std::mem::size_of::<CK_PKCS5_PBKD2_PARAMS2>(),
        36usize,
        concat!("Size of: ", stringify!(CK_PKCS5_PBKD2_PARAMS2))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_PKCS5_PBKD2_PARAMS2>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_PKCS5_PBKD2_PARAMS2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).saltSource as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(saltSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).pSaltSourceData as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(pSaltSourceData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).ulSaltSourceDataLen as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(ulSaltSourceDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).iterations as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(iterations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).prf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(prf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).pPrfData as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(pPrfData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).ulPrfDataLen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(ulPrfDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).pPassword as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(pPassword)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_PKCS5_PBKD2_PARAMS2>())).ulPasswordLen as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_PKCS5_PBKD2_PARAMS2),
            "::",
            stringify!(ulPasswordLen)
        )
    );
}
impl Default for CK_PKCS5_PBKD2_PARAMS2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_PKCS5_PBKD2_PARAMS2_PTR = *mut CK_PKCS5_PBKD2_PARAMS2;
pub type CK_OTP_PARAM_TYPE = CK_ULONG;
pub type CK_PARAM_TYPE = CK_OTP_PARAM_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_OTP_PARAM {
    pub type_: CK_OTP_PARAM_TYPE,
    pub pValue: CK_VOID_PTR,
    pub ulValueLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_OTP_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<CK_OTP_PARAM>(),
        12usize,
        concat!("Size of: ", stringify!(CK_OTP_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_OTP_PARAM>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_OTP_PARAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_OTP_PARAM>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_OTP_PARAM),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_OTP_PARAM>())).pValue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_OTP_PARAM),
            "::",
            stringify!(pValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_OTP_PARAM>())).ulValueLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_OTP_PARAM),
            "::",
            stringify!(ulValueLen)
        )
    );
}
impl Default for CK_OTP_PARAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_OTP_PARAM_PTR = *mut CK_OTP_PARAM;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_OTP_PARAMS {
    pub pParams: CK_OTP_PARAM_PTR,
    pub ulCount: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_OTP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_OTP_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(CK_OTP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_OTP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_OTP_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_OTP_PARAMS>())).pParams as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_OTP_PARAMS),
            "::",
            stringify!(pParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_OTP_PARAMS>())).ulCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_OTP_PARAMS),
            "::",
            stringify!(ulCount)
        )
    );
}
impl Default for CK_OTP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_OTP_PARAMS_PTR = *mut CK_OTP_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_OTP_SIGNATURE_INFO {
    pub pParams: CK_OTP_PARAM_PTR,
    pub ulCount: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_OTP_SIGNATURE_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CK_OTP_SIGNATURE_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(CK_OTP_SIGNATURE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_OTP_SIGNATURE_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_OTP_SIGNATURE_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_OTP_SIGNATURE_INFO>())).pParams as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_OTP_SIGNATURE_INFO),
            "::",
            stringify!(pParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_OTP_SIGNATURE_INFO>())).ulCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_OTP_SIGNATURE_INFO),
            "::",
            stringify!(ulCount)
        )
    );
}
impl Default for CK_OTP_SIGNATURE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_OTP_SIGNATURE_INFO_PTR = *mut CK_OTP_SIGNATURE_INFO;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_KIP_PARAMS {
    pub pMechanism: CK_MECHANISM_PTR,
    pub hKey: CK_OBJECT_HANDLE,
    pub pSeed: CK_BYTE_PTR,
    pub ulSeedLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_KIP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_KIP_PARAMS>(),
        16usize,
        concat!("Size of: ", stringify!(CK_KIP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_KIP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_KIP_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KIP_PARAMS>())).pMechanism as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KIP_PARAMS),
            "::",
            stringify!(pMechanism)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KIP_PARAMS>())).hKey as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KIP_PARAMS),
            "::",
            stringify!(hKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KIP_PARAMS>())).pSeed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KIP_PARAMS),
            "::",
            stringify!(pSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_KIP_PARAMS>())).ulSeedLen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_KIP_PARAMS),
            "::",
            stringify!(ulSeedLen)
        )
    );
}
impl Default for CK_KIP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_KIP_PARAMS_PTR = *mut CK_KIP_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_AES_CTR_PARAMS {
    pub ulCounterBits: CK_ULONG,
    pub cb: [CK_BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_CK_AES_CTR_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_AES_CTR_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_AES_CTR_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_AES_CTR_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_AES_CTR_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_AES_CTR_PARAMS>())).ulCounterBits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_AES_CTR_PARAMS),
            "::",
            stringify!(ulCounterBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_AES_CTR_PARAMS>())).cb as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_AES_CTR_PARAMS),
            "::",
            stringify!(cb)
        )
    );
}
pub type CK_AES_CTR_PARAMS_PTR = *mut CK_AES_CTR_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_GCM_PARAMS {
    pub pIv: CK_BYTE_PTR,
    pub ulIvLen: CK_ULONG,
    pub ulIvBits: CK_ULONG,
    pub pAAD: CK_BYTE_PTR,
    pub ulAADLen: CK_ULONG,
    pub ulTagBits: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_GCM_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_GCM_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_GCM_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_GCM_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_GCM_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GCM_PARAMS>())).pIv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GCM_PARAMS),
            "::",
            stringify!(pIv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GCM_PARAMS>())).ulIvLen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GCM_PARAMS),
            "::",
            stringify!(ulIvLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GCM_PARAMS>())).ulIvBits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GCM_PARAMS),
            "::",
            stringify!(ulIvBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GCM_PARAMS>())).pAAD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GCM_PARAMS),
            "::",
            stringify!(pAAD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GCM_PARAMS>())).ulAADLen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GCM_PARAMS),
            "::",
            stringify!(ulAADLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GCM_PARAMS>())).ulTagBits as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GCM_PARAMS),
            "::",
            stringify!(ulTagBits)
        )
    );
}
impl Default for CK_GCM_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_GCM_PARAMS_PTR = *mut CK_GCM_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_CCM_PARAMS {
    pub ulDataLen: CK_ULONG,
    pub pNonce: CK_BYTE_PTR,
    pub ulNonceLen: CK_ULONG,
    pub pAAD: CK_BYTE_PTR,
    pub ulAADLen: CK_ULONG,
    pub ulMACLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_CCM_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_CCM_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_CCM_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_CCM_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_CCM_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CCM_PARAMS>())).ulDataLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CCM_PARAMS),
            "::",
            stringify!(ulDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CCM_PARAMS>())).pNonce as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CCM_PARAMS),
            "::",
            stringify!(pNonce)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CCM_PARAMS>())).ulNonceLen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CCM_PARAMS),
            "::",
            stringify!(ulNonceLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CCM_PARAMS>())).pAAD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CCM_PARAMS),
            "::",
            stringify!(pAAD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CCM_PARAMS>())).ulAADLen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CCM_PARAMS),
            "::",
            stringify!(ulAADLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CCM_PARAMS>())).ulMACLen as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CCM_PARAMS),
            "::",
            stringify!(ulMACLen)
        )
    );
}
impl Default for CK_CCM_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_CCM_PARAMS_PTR = *mut CK_CCM_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_CAMELLIA_CTR_PARAMS {
    pub ulCounterBits: CK_ULONG,
    pub cb: [CK_BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_CK_CAMELLIA_CTR_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_CAMELLIA_CTR_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_CAMELLIA_CTR_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_CAMELLIA_CTR_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_CAMELLIA_CTR_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CAMELLIA_CTR_PARAMS>())).ulCounterBits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CAMELLIA_CTR_PARAMS),
            "::",
            stringify!(ulCounterBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_CAMELLIA_CTR_PARAMS>())).cb as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CAMELLIA_CTR_PARAMS),
            "::",
            stringify!(cb)
        )
    );
}
pub type CK_CAMELLIA_CTR_PARAMS_PTR = *mut CK_CAMELLIA_CTR_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS {
    pub iv: [CK_BYTE; 16usize],
    pub pData: CK_BYTE_PTR,
    pub length: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS>())).iv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS>())).pData as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS>())).length as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(length)
        )
    );
}
impl Default for CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS_PTR = *mut CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_ARIA_CBC_ENCRYPT_DATA_PARAMS {
    pub iv: [CK_BYTE; 16usize],
    pub pData: CK_BYTE_PTR,
    pub length: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_ARIA_CBC_ENCRYPT_DATA_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_ARIA_CBC_ENCRYPT_DATA_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_ARIA_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_ARIA_CBC_ENCRYPT_DATA_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_ARIA_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ARIA_CBC_ENCRYPT_DATA_PARAMS>())).iv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ARIA_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ARIA_CBC_ENCRYPT_DATA_PARAMS>())).pData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ARIA_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ARIA_CBC_ENCRYPT_DATA_PARAMS>())).length as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ARIA_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(length)
        )
    );
}
impl Default for CK_ARIA_CBC_ENCRYPT_DATA_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_ARIA_CBC_ENCRYPT_DATA_PARAMS_PTR = *mut CK_ARIA_CBC_ENCRYPT_DATA_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_DSA_PARAMETER_GEN_PARAM {
    pub hash: CK_MECHANISM_TYPE,
    pub pSeed: CK_BYTE_PTR,
    pub ulSeedLen: CK_ULONG,
    pub ulIndex: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_DSA_PARAMETER_GEN_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<CK_DSA_PARAMETER_GEN_PARAM>(),
        16usize,
        concat!("Size of: ", stringify!(CK_DSA_PARAMETER_GEN_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_DSA_PARAMETER_GEN_PARAM>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_DSA_PARAMETER_GEN_PARAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_DSA_PARAMETER_GEN_PARAM>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DSA_PARAMETER_GEN_PARAM),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_DSA_PARAMETER_GEN_PARAM>())).pSeed as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DSA_PARAMETER_GEN_PARAM),
            "::",
            stringify!(pSeed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_DSA_PARAMETER_GEN_PARAM>())).ulSeedLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DSA_PARAMETER_GEN_PARAM),
            "::",
            stringify!(ulSeedLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_DSA_PARAMETER_GEN_PARAM>())).ulIndex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_DSA_PARAMETER_GEN_PARAM),
            "::",
            stringify!(ulIndex)
        )
    );
}
impl Default for CK_DSA_PARAMETER_GEN_PARAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_DSA_PARAMETER_GEN_PARAM_PTR = *mut CK_DSA_PARAMETER_GEN_PARAM;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_ECDH_AES_KEY_WRAP_PARAMS {
    pub ulAESKeyBits: CK_ULONG,
    pub kdf: CK_EC_KDF_TYPE,
    pub ulSharedDataLen: CK_ULONG,
    pub pSharedData: CK_BYTE_PTR,
}
#[test]
fn bindgen_test_layout_CK_ECDH_AES_KEY_WRAP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_ECDH_AES_KEY_WRAP_PARAMS>(),
        16usize,
        concat!("Size of: ", stringify!(CK_ECDH_AES_KEY_WRAP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_ECDH_AES_KEY_WRAP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_ECDH_AES_KEY_WRAP_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH_AES_KEY_WRAP_PARAMS>())).ulAESKeyBits as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH_AES_KEY_WRAP_PARAMS),
            "::",
            stringify!(ulAESKeyBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_ECDH_AES_KEY_WRAP_PARAMS>())).kdf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH_AES_KEY_WRAP_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH_AES_KEY_WRAP_PARAMS>())).ulSharedDataLen as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH_AES_KEY_WRAP_PARAMS),
            "::",
            stringify!(ulSharedDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_ECDH_AES_KEY_WRAP_PARAMS>())).pSharedData as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_ECDH_AES_KEY_WRAP_PARAMS),
            "::",
            stringify!(pSharedData)
        )
    );
}
impl Default for CK_ECDH_AES_KEY_WRAP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_ECDH_AES_KEY_WRAP_PARAMS_PTR = *mut CK_ECDH_AES_KEY_WRAP_PARAMS;
pub type CK_JAVA_MIDP_SECURITY_DOMAIN = CK_ULONG;
pub type CK_CERTIFICATE_CATEGORY = CK_ULONG;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_RSA_AES_KEY_WRAP_PARAMS {
    pub ulAESKeyBits: CK_ULONG,
    pub pOAEPParams: CK_RSA_PKCS_OAEP_PARAMS_PTR,
}
#[test]
fn bindgen_test_layout_CK_RSA_AES_KEY_WRAP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_RSA_AES_KEY_WRAP_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(CK_RSA_AES_KEY_WRAP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_RSA_AES_KEY_WRAP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_RSA_AES_KEY_WRAP_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RSA_AES_KEY_WRAP_PARAMS>())).ulAESKeyBits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_AES_KEY_WRAP_PARAMS),
            "::",
            stringify!(ulAESKeyBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_RSA_AES_KEY_WRAP_PARAMS>())).pOAEPParams as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_RSA_AES_KEY_WRAP_PARAMS),
            "::",
            stringify!(pOAEPParams)
        )
    );
}
impl Default for CK_RSA_AES_KEY_WRAP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_RSA_AES_KEY_WRAP_PARAMS_PTR = *mut CK_RSA_AES_KEY_WRAP_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_TLS12_MASTER_KEY_DERIVE_PARAMS {
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pVersion: CK_VERSION_PTR,
    pub prfHashMechanism: CK_MECHANISM_TYPE,
}
#[test]
fn bindgen_test_layout_CK_TLS12_MASTER_KEY_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_TLS12_MASTER_KEY_DERIVE_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_TLS12_MASTER_KEY_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_TLS12_MASTER_KEY_DERIVE_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CK_TLS12_MASTER_KEY_DERIVE_PARAMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_MASTER_KEY_DERIVE_PARAMS>())).RandomInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(RandomInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_MASTER_KEY_DERIVE_PARAMS>())).pVersion as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(pVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_MASTER_KEY_DERIVE_PARAMS>())).prfHashMechanism
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_MASTER_KEY_DERIVE_PARAMS),
            "::",
            stringify!(prfHashMechanism)
        )
    );
}
impl Default for CK_TLS12_MASTER_KEY_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_TLS12_MASTER_KEY_DERIVE_PARAMS_PTR = *mut CK_TLS12_MASTER_KEY_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_TLS12_KEY_MAT_PARAMS {
    pub ulMacSizeInBits: CK_ULONG,
    pub ulKeySizeInBits: CK_ULONG,
    pub ulIVSizeInBits: CK_ULONG,
    pub bIsExport: CK_BBOOL,
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pReturnedKeyMaterial: CK_SSL3_KEY_MAT_OUT_PTR,
    pub prfHashMechanism: CK_MECHANISM_TYPE,
}
#[test]
fn bindgen_test_layout_CK_TLS12_KEY_MAT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_TLS12_KEY_MAT_PARAMS>(),
        37usize,
        concat!("Size of: ", stringify!(CK_TLS12_KEY_MAT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_TLS12_KEY_MAT_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_TLS12_KEY_MAT_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_KEY_MAT_PARAMS>())).ulMacSizeInBits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_KEY_MAT_PARAMS),
            "::",
            stringify!(ulMacSizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_KEY_MAT_PARAMS>())).ulKeySizeInBits as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_KEY_MAT_PARAMS),
            "::",
            stringify!(ulKeySizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_KEY_MAT_PARAMS>())).ulIVSizeInBits as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_KEY_MAT_PARAMS),
            "::",
            stringify!(ulIVSizeInBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_KEY_MAT_PARAMS>())).bIsExport as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_KEY_MAT_PARAMS),
            "::",
            stringify!(bIsExport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_KEY_MAT_PARAMS>())).RandomInfo as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_KEY_MAT_PARAMS),
            "::",
            stringify!(RandomInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_KEY_MAT_PARAMS>())).pReturnedKeyMaterial as *const _
                as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_KEY_MAT_PARAMS),
            "::",
            stringify!(pReturnedKeyMaterial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS12_KEY_MAT_PARAMS>())).prfHashMechanism as *const _
                as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS12_KEY_MAT_PARAMS),
            "::",
            stringify!(prfHashMechanism)
        )
    );
}
impl Default for CK_TLS12_KEY_MAT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_TLS12_KEY_MAT_PARAMS_PTR = *mut CK_TLS12_KEY_MAT_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_TLS_KDF_PARAMS {
    pub prfMechanism: CK_MECHANISM_TYPE,
    pub pLabel: CK_BYTE_PTR,
    pub ulLabelLength: CK_ULONG,
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pContextData: CK_BYTE_PTR,
    pub ulContextDataLength: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_TLS_KDF_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_TLS_KDF_PARAMS>(),
        36usize,
        concat!("Size of: ", stringify!(CK_TLS_KDF_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_TLS_KDF_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_TLS_KDF_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_KDF_PARAMS>())).prfMechanism as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_KDF_PARAMS),
            "::",
            stringify!(prfMechanism)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_KDF_PARAMS>())).pLabel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_KDF_PARAMS),
            "::",
            stringify!(pLabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_KDF_PARAMS>())).ulLabelLength as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_KDF_PARAMS),
            "::",
            stringify!(ulLabelLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_KDF_PARAMS>())).RandomInfo as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_KDF_PARAMS),
            "::",
            stringify!(RandomInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_KDF_PARAMS>())).pContextData as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_KDF_PARAMS),
            "::",
            stringify!(pContextData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS_KDF_PARAMS>())).ulContextDataLength as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_KDF_PARAMS),
            "::",
            stringify!(ulContextDataLength)
        )
    );
}
impl Default for CK_TLS_KDF_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_TLS_KDF_PARAMS_PTR = *mut CK_TLS_KDF_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_TLS_MAC_PARAMS {
    pub prfHashMechanism: CK_MECHANISM_TYPE,
    pub ulMacLength: CK_ULONG,
    pub ulServerOrClient: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_TLS_MAC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_TLS_MAC_PARAMS>(),
        12usize,
        concat!("Size of: ", stringify!(CK_TLS_MAC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_TLS_MAC_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_TLS_MAC_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS_MAC_PARAMS>())).prfHashMechanism as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_MAC_PARAMS),
            "::",
            stringify!(prfHashMechanism)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_TLS_MAC_PARAMS>())).ulMacLength as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_MAC_PARAMS),
            "::",
            stringify!(ulMacLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_TLS_MAC_PARAMS>())).ulServerOrClient as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_TLS_MAC_PARAMS),
            "::",
            stringify!(ulServerOrClient)
        )
    );
}
pub type CK_TLS_MAC_PARAMS_PTR = *mut CK_TLS_MAC_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_GOSTR3410_DERIVE_PARAMS {
    pub kdf: CK_EC_KDF_TYPE,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pUKM: CK_BYTE_PTR,
    pub ulUKMLen: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_GOSTR3410_DERIVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_GOSTR3410_DERIVE_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_GOSTR3410_DERIVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_GOSTR3410_DERIVE_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_GOSTR3410_DERIVE_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GOSTR3410_DERIVE_PARAMS>())).kdf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_DERIVE_PARAMS),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_DERIVE_PARAMS>())).pPublicData as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_DERIVE_PARAMS),
            "::",
            stringify!(pPublicData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_DERIVE_PARAMS>())).ulPublicDataLen as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_DERIVE_PARAMS),
            "::",
            stringify!(ulPublicDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_GOSTR3410_DERIVE_PARAMS>())).pUKM as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_DERIVE_PARAMS),
            "::",
            stringify!(pUKM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_DERIVE_PARAMS>())).ulUKMLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_DERIVE_PARAMS),
            "::",
            stringify!(ulUKMLen)
        )
    );
}
impl Default for CK_GOSTR3410_DERIVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_GOSTR3410_DERIVE_PARAMS_PTR = *mut CK_GOSTR3410_DERIVE_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_GOSTR3410_KEY_WRAP_PARAMS {
    pub pWrapOID: CK_BYTE_PTR,
    pub ulWrapOIDLen: CK_ULONG,
    pub pUKM: CK_BYTE_PTR,
    pub ulUKMLen: CK_ULONG,
    pub hKey: CK_OBJECT_HANDLE,
}
#[test]
fn bindgen_test_layout_CK_GOSTR3410_KEY_WRAP_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_GOSTR3410_KEY_WRAP_PARAMS>(),
        20usize,
        concat!("Size of: ", stringify!(CK_GOSTR3410_KEY_WRAP_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_GOSTR3410_KEY_WRAP_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_GOSTR3410_KEY_WRAP_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_KEY_WRAP_PARAMS>())).pWrapOID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_KEY_WRAP_PARAMS),
            "::",
            stringify!(pWrapOID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_KEY_WRAP_PARAMS>())).ulWrapOIDLen as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_KEY_WRAP_PARAMS),
            "::",
            stringify!(ulWrapOIDLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_KEY_WRAP_PARAMS>())).pUKM as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_KEY_WRAP_PARAMS),
            "::",
            stringify!(pUKM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_KEY_WRAP_PARAMS>())).ulUKMLen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_KEY_WRAP_PARAMS),
            "::",
            stringify!(ulUKMLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_GOSTR3410_KEY_WRAP_PARAMS>())).hKey as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_GOSTR3410_KEY_WRAP_PARAMS),
            "::",
            stringify!(hKey)
        )
    );
}
impl Default for CK_GOSTR3410_KEY_WRAP_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_GOSTR3410_KEY_WRAP_PARAMS_PTR = *mut CK_GOSTR3410_KEY_WRAP_PARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SEED_CBC_ENCRYPT_DATA_PARAMS {
    pub iv: [CK_BYTE; 16usize],
    pub pData: CK_BYTE_PTR,
    pub length: CK_ULONG,
}
#[test]
fn bindgen_test_layout_CK_SEED_CBC_ENCRYPT_DATA_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<CK_SEED_CBC_ENCRYPT_DATA_PARAMS>(),
        24usize,
        concat!("Size of: ", stringify!(CK_SEED_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_SEED_CBC_ENCRYPT_DATA_PARAMS>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_SEED_CBC_ENCRYPT_DATA_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SEED_CBC_ENCRYPT_DATA_PARAMS>())).iv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SEED_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SEED_CBC_ENCRYPT_DATA_PARAMS>())).pData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SEED_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_SEED_CBC_ENCRYPT_DATA_PARAMS>())).length as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_SEED_CBC_ENCRYPT_DATA_PARAMS),
            "::",
            stringify!(length)
        )
    );
}
impl Default for CK_SEED_CBC_ENCRYPT_DATA_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CK_SEED_CBC_ENCRYPT_DATA_PARAMS_PTR = *mut CK_SEED_CBC_ENCRYPT_DATA_PARAMS;
pub type CK_C_Initialize =
    ::std::option::Option<unsafe extern "C" fn(pInitArgs: CK_VOID_PTR) -> CK_RV>;
pub type CK_C_Finalize =
    ::std::option::Option<unsafe extern "C" fn(pReserved: CK_VOID_PTR) -> CK_RV>;
pub type CK_C_GetInfo = ::std::option::Option<unsafe extern "C" fn(pInfo: CK_INFO_PTR) -> CK_RV>;
pub type CK_C_GetFunctionList =
    ::std::option::Option<unsafe extern "C" fn(ppFunctionList: CK_FUNCTION_LIST_PTR_PTR) -> CK_RV>;
pub type CK_C_GetSlotList = ::std::option::Option<
    unsafe extern "C" fn(
        tokenPresent: CK_BBOOL,
        pSlotList: CK_SLOT_ID_PTR,
        pulCount: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_GetSlotInfo = ::std::option::Option<
    unsafe extern "C" fn(slotID: CK_SLOT_ID, pInfo: CK_SLOT_INFO_PTR) -> CK_RV,
>;
pub type CK_C_GetTokenInfo = ::std::option::Option<
    unsafe extern "C" fn(slotID: CK_SLOT_ID, pInfo: CK_TOKEN_INFO_PTR) -> CK_RV,
>;
pub type CK_C_GetMechanismList = ::std::option::Option<
    unsafe extern "C" fn(
        slotID: CK_SLOT_ID,
        pMechanismList: CK_MECHANISM_TYPE_PTR,
        pulCount: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_GetMechanismInfo = ::std::option::Option<
    unsafe extern "C" fn(
        slotID: CK_SLOT_ID,
        type_: CK_MECHANISM_TYPE,
        pInfo: CK_MECHANISM_INFO_PTR,
    ) -> CK_RV,
>;
pub type CK_C_InitToken = ::std::option::Option<
    unsafe extern "C" fn(
        slotID: CK_SLOT_ID,
        pPin: CK_UTF8CHAR_PTR,
        ulPinLen: CK_ULONG,
        pLabel: CK_UTF8CHAR_PTR,
    ) -> CK_RV,
>;
pub type CK_C_InitPIN = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pPin: CK_UTF8CHAR_PTR,
        ulPinLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_SetPIN = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pOldPin: CK_UTF8CHAR_PTR,
        ulOldLen: CK_ULONG,
        pNewPin: CK_UTF8CHAR_PTR,
        ulNewLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_OpenSession = ::std::option::Option<
    unsafe extern "C" fn(
        slotID: CK_SLOT_ID,
        flags: CK_FLAGS,
        pApplication: CK_VOID_PTR,
        Notify: CK_NOTIFY,
        phSession: CK_SESSION_HANDLE_PTR,
    ) -> CK_RV,
>;
pub type CK_C_CloseSession =
    ::std::option::Option<unsafe extern "C" fn(hSession: CK_SESSION_HANDLE) -> CK_RV>;
pub type CK_C_CloseAllSessions =
    ::std::option::Option<unsafe extern "C" fn(slotID: CK_SLOT_ID) -> CK_RV>;
pub type CK_C_GetSessionInfo = ::std::option::Option<
    unsafe extern "C" fn(hSession: CK_SESSION_HANDLE, pInfo: CK_SESSION_INFO_PTR) -> CK_RV,
>;
pub type CK_C_GetOperationState = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pOperationState: CK_BYTE_PTR,
        pulOperationStateLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_SetOperationState = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pOperationState: CK_BYTE_PTR,
        ulOperationStateLen: CK_ULONG,
        hEncryptionKey: CK_OBJECT_HANDLE,
        hAuthenticationKey: CK_OBJECT_HANDLE,
    ) -> CK_RV,
>;
pub type CK_C_Login = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        userType: CK_USER_TYPE,
        pPin: CK_UTF8CHAR_PTR,
        ulPinLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_Logout =
    ::std::option::Option<unsafe extern "C" fn(hSession: CK_SESSION_HANDLE) -> CK_RV>;
pub type CK_C_CreateObject = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulCount: CK_ULONG,
        phObject: CK_OBJECT_HANDLE_PTR,
    ) -> CK_RV,
>;
pub type CK_C_CopyObject = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        hObject: CK_OBJECT_HANDLE,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulCount: CK_ULONG,
        phNewObject: CK_OBJECT_HANDLE_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DestroyObject = ::std::option::Option<
    unsafe extern "C" fn(hSession: CK_SESSION_HANDLE, hObject: CK_OBJECT_HANDLE) -> CK_RV,
>;
pub type CK_C_GetObjectSize = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        hObject: CK_OBJECT_HANDLE,
        pulSize: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_GetAttributeValue = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        hObject: CK_OBJECT_HANDLE,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulCount: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_SetAttributeValue = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        hObject: CK_OBJECT_HANDLE,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulCount: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_FindObjectsInit = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulCount: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_FindObjects = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        phObject: CK_OBJECT_HANDLE_PTR,
        ulMaxObjectCount: CK_ULONG,
        pulObjectCount: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_FindObjectsFinal =
    ::std::option::Option<unsafe extern "C" fn(hSession: CK_SESSION_HANDLE) -> CK_RV>;
pub type CK_C_EncryptInit = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hKey: CK_OBJECT_HANDLE,
    ) -> CK_RV,
>;
pub type CK_C_Encrypt = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pData: CK_BYTE_PTR,
        ulDataLen: CK_ULONG,
        pEncryptedData: CK_BYTE_PTR,
        pulEncryptedDataLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_EncryptUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pPart: CK_BYTE_PTR,
        ulPartLen: CK_ULONG,
        pEncryptedPart: CK_BYTE_PTR,
        pulEncryptedPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_EncryptFinal = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pLastEncryptedPart: CK_BYTE_PTR,
        pulLastEncryptedPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DecryptInit = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hKey: CK_OBJECT_HANDLE,
    ) -> CK_RV,
>;
pub type CK_C_Decrypt = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pEncryptedData: CK_BYTE_PTR,
        ulEncryptedDataLen: CK_ULONG,
        pData: CK_BYTE_PTR,
        pulDataLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DecryptUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pEncryptedPart: CK_BYTE_PTR,
        ulEncryptedPartLen: CK_ULONG,
        pPart: CK_BYTE_PTR,
        pulPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DecryptFinal = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pLastPart: CK_BYTE_PTR,
        pulLastPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DigestInit = ::std::option::Option<
    unsafe extern "C" fn(hSession: CK_SESSION_HANDLE, pMechanism: CK_MECHANISM_PTR) -> CK_RV,
>;
pub type CK_C_Digest = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pData: CK_BYTE_PTR,
        ulDataLen: CK_ULONG,
        pDigest: CK_BYTE_PTR,
        pulDigestLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DigestUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pPart: CK_BYTE_PTR,
        ulPartLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_DigestKey = ::std::option::Option<
    unsafe extern "C" fn(hSession: CK_SESSION_HANDLE, hKey: CK_OBJECT_HANDLE) -> CK_RV,
>;
pub type CK_C_DigestFinal = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pDigest: CK_BYTE_PTR,
        pulDigestLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_SignInit = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hKey: CK_OBJECT_HANDLE,
    ) -> CK_RV,
>;
pub type CK_C_Sign = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pData: CK_BYTE_PTR,
        ulDataLen: CK_ULONG,
        pSignature: CK_BYTE_PTR,
        pulSignatureLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_SignUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pPart: CK_BYTE_PTR,
        ulPartLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_SignFinal = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pSignature: CK_BYTE_PTR,
        pulSignatureLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_SignRecoverInit = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hKey: CK_OBJECT_HANDLE,
    ) -> CK_RV,
>;
pub type CK_C_SignRecover = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pData: CK_BYTE_PTR,
        ulDataLen: CK_ULONG,
        pSignature: CK_BYTE_PTR,
        pulSignatureLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_VerifyInit = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hKey: CK_OBJECT_HANDLE,
    ) -> CK_RV,
>;
pub type CK_C_Verify = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pData: CK_BYTE_PTR,
        ulDataLen: CK_ULONG,
        pSignature: CK_BYTE_PTR,
        ulSignatureLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_VerifyUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pPart: CK_BYTE_PTR,
        ulPartLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_VerifyFinal = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pSignature: CK_BYTE_PTR,
        ulSignatureLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_VerifyRecoverInit = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hKey: CK_OBJECT_HANDLE,
    ) -> CK_RV,
>;
pub type CK_C_VerifyRecover = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pSignature: CK_BYTE_PTR,
        ulSignatureLen: CK_ULONG,
        pData: CK_BYTE_PTR,
        pulDataLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DigestEncryptUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pPart: CK_BYTE_PTR,
        ulPartLen: CK_ULONG,
        pEncryptedPart: CK_BYTE_PTR,
        pulEncryptedPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DecryptDigestUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pEncryptedPart: CK_BYTE_PTR,
        ulEncryptedPartLen: CK_ULONG,
        pPart: CK_BYTE_PTR,
        pulPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_SignEncryptUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pPart: CK_BYTE_PTR,
        ulPartLen: CK_ULONG,
        pEncryptedPart: CK_BYTE_PTR,
        pulEncryptedPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DecryptVerifyUpdate = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pEncryptedPart: CK_BYTE_PTR,
        ulEncryptedPartLen: CK_ULONG,
        pPart: CK_BYTE_PTR,
        pulPartLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_GenerateKey = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulCount: CK_ULONG,
        phKey: CK_OBJECT_HANDLE_PTR,
    ) -> CK_RV,
>;
pub type CK_C_GenerateKeyPair = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        pPublicKeyTemplate: CK_ATTRIBUTE_PTR,
        ulPublicKeyAttributeCount: CK_ULONG,
        pPrivateKeyTemplate: CK_ATTRIBUTE_PTR,
        ulPrivateKeyAttributeCount: CK_ULONG,
        phPublicKey: CK_OBJECT_HANDLE_PTR,
        phPrivateKey: CK_OBJECT_HANDLE_PTR,
    ) -> CK_RV,
>;
pub type CK_C_WrapKey = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hWrappingKey: CK_OBJECT_HANDLE,
        hKey: CK_OBJECT_HANDLE,
        pWrappedKey: CK_BYTE_PTR,
        pulWrappedKeyLen: CK_ULONG_PTR,
    ) -> CK_RV,
>;
pub type CK_C_UnwrapKey = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hUnwrappingKey: CK_OBJECT_HANDLE,
        pWrappedKey: CK_BYTE_PTR,
        ulWrappedKeyLen: CK_ULONG,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulAttributeCount: CK_ULONG,
        phKey: CK_OBJECT_HANDLE_PTR,
    ) -> CK_RV,
>;
pub type CK_C_DeriveKey = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pMechanism: CK_MECHANISM_PTR,
        hBaseKey: CK_OBJECT_HANDLE,
        pTemplate: CK_ATTRIBUTE_PTR,
        ulAttributeCount: CK_ULONG,
        phKey: CK_OBJECT_HANDLE_PTR,
    ) -> CK_RV,
>;
pub type CK_C_SeedRandom = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        pSeed: CK_BYTE_PTR,
        ulSeedLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_GenerateRandom = ::std::option::Option<
    unsafe extern "C" fn(
        hSession: CK_SESSION_HANDLE,
        RandomData: CK_BYTE_PTR,
        ulRandomLen: CK_ULONG,
    ) -> CK_RV,
>;
pub type CK_C_GetFunctionStatus =
    ::std::option::Option<unsafe extern "C" fn(hSession: CK_SESSION_HANDLE) -> CK_RV>;
pub type CK_C_CancelFunction =
    ::std::option::Option<unsafe extern "C" fn(hSession: CK_SESSION_HANDLE) -> CK_RV>;
pub type CK_C_WaitForSlotEvent = ::std::option::Option<
    unsafe extern "C" fn(flags: CK_FLAGS, pSlot: CK_SLOT_ID_PTR, pRserved: CK_VOID_PTR) -> CK_RV,
>;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CK_FUNCTION_LIST {
    pub version: CK_VERSION,
    pub C_Initialize: CK_C_Initialize,
    pub C_Finalize: CK_C_Finalize,
    pub C_GetInfo: CK_C_GetInfo,
    pub C_GetFunctionList: CK_C_GetFunctionList,
    pub C_GetSlotList: CK_C_GetSlotList,
    pub C_GetSlotInfo: CK_C_GetSlotInfo,
    pub C_GetTokenInfo: CK_C_GetTokenInfo,
    pub C_GetMechanismList: CK_C_GetMechanismList,
    pub C_GetMechanismInfo: CK_C_GetMechanismInfo,
    pub C_InitToken: CK_C_InitToken,
    pub C_InitPIN: CK_C_InitPIN,
    pub C_SetPIN: CK_C_SetPIN,
    pub C_OpenSession: CK_C_OpenSession,
    pub C_CloseSession: CK_C_CloseSession,
    pub C_CloseAllSessions: CK_C_CloseAllSessions,
    pub C_GetSessionInfo: CK_C_GetSessionInfo,
    pub C_GetOperationState: CK_C_GetOperationState,
    pub C_SetOperationState: CK_C_SetOperationState,
    pub C_Login: CK_C_Login,
    pub C_Logout: CK_C_Logout,
    pub C_CreateObject: CK_C_CreateObject,
    pub C_CopyObject: CK_C_CopyObject,
    pub C_DestroyObject: CK_C_DestroyObject,
    pub C_GetObjectSize: CK_C_GetObjectSize,
    pub C_GetAttributeValue: CK_C_GetAttributeValue,
    pub C_SetAttributeValue: CK_C_SetAttributeValue,
    pub C_FindObjectsInit: CK_C_FindObjectsInit,
    pub C_FindObjects: CK_C_FindObjects,
    pub C_FindObjectsFinal: CK_C_FindObjectsFinal,
    pub C_EncryptInit: CK_C_EncryptInit,
    pub C_Encrypt: CK_C_Encrypt,
    pub C_EncryptUpdate: CK_C_EncryptUpdate,
    pub C_EncryptFinal: CK_C_EncryptFinal,
    pub C_DecryptInit: CK_C_DecryptInit,
    pub C_Decrypt: CK_C_Decrypt,
    pub C_DecryptUpdate: CK_C_DecryptUpdate,
    pub C_DecryptFinal: CK_C_DecryptFinal,
    pub C_DigestInit: CK_C_DigestInit,
    pub C_Digest: CK_C_Digest,
    pub C_DigestUpdate: CK_C_DigestUpdate,
    pub C_DigestKey: CK_C_DigestKey,
    pub C_DigestFinal: CK_C_DigestFinal,
    pub C_SignInit: CK_C_SignInit,
    pub C_Sign: CK_C_Sign,
    pub C_SignUpdate: CK_C_SignUpdate,
    pub C_SignFinal: CK_C_SignFinal,
    pub C_SignRecoverInit: CK_C_SignRecoverInit,
    pub C_SignRecover: CK_C_SignRecover,
    pub C_VerifyInit: CK_C_VerifyInit,
    pub C_Verify: CK_C_Verify,
    pub C_VerifyUpdate: CK_C_VerifyUpdate,
    pub C_VerifyFinal: CK_C_VerifyFinal,
    pub C_VerifyRecoverInit: CK_C_VerifyRecoverInit,
    pub C_VerifyRecover: CK_C_VerifyRecover,
    pub C_DigestEncryptUpdate: CK_C_DigestEncryptUpdate,
    pub C_DecryptDigestUpdate: CK_C_DecryptDigestUpdate,
    pub C_SignEncryptUpdate: CK_C_SignEncryptUpdate,
    pub C_DecryptVerifyUpdate: CK_C_DecryptVerifyUpdate,
    pub C_GenerateKey: CK_C_GenerateKey,
    pub C_GenerateKeyPair: CK_C_GenerateKeyPair,
    pub C_WrapKey: CK_C_WrapKey,
    pub C_UnwrapKey: CK_C_UnwrapKey,
    pub C_DeriveKey: CK_C_DeriveKey,
    pub C_SeedRandom: CK_C_SeedRandom,
    pub C_GenerateRandom: CK_C_GenerateRandom,
    pub C_GetFunctionStatus: CK_C_GetFunctionStatus,
    pub C_CancelFunction: CK_C_CancelFunction,
    pub C_WaitForSlotEvent: CK_C_WaitForSlotEvent,
}
#[test]
fn bindgen_test_layout_CK_FUNCTION_LIST() {
    assert_eq!(
        ::std::mem::size_of::<CK_FUNCTION_LIST>(),
        274usize,
        concat!("Size of: ", stringify!(CK_FUNCTION_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<CK_FUNCTION_LIST>(),
        1usize,
        concat!("Alignment of ", stringify!(CK_FUNCTION_LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Initialize as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Initialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Finalize as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetInfo as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetFunctionList as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetFunctionList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetSlotList as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetSlotList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetSlotInfo as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetSlotInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetTokenInfo as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetTokenInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetMechanismList as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetMechanismList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetMechanismInfo as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetMechanismInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_InitToken as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_InitToken)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_InitPIN as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_InitPIN)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SetPIN as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SetPIN)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_OpenSession as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_OpenSession)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_CloseSession as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_CloseSession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_CloseAllSessions as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_CloseAllSessions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetSessionInfo as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetSessionInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetOperationState as *const _ as usize
        },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetOperationState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SetOperationState as *const _ as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SetOperationState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Login as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Login)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Logout as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Logout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_CreateObject as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_CreateObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_CopyObject as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_CopyObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DestroyObject as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DestroyObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetObjectSize as *const _ as usize
        },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetObjectSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetAttributeValue as *const _ as usize
        },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetAttributeValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SetAttributeValue as *const _ as usize
        },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SetAttributeValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_FindObjectsInit as *const _ as usize
        },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_FindObjectsInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_FindObjects as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_FindObjects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_FindObjectsFinal as *const _ as usize
        },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_FindObjectsFinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_EncryptInit as *const _ as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_EncryptInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Encrypt as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Encrypt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_EncryptUpdate as *const _ as usize
        },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_EncryptUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_EncryptFinal as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_EncryptFinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DecryptInit as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DecryptInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Decrypt as *const _ as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Decrypt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DecryptUpdate as *const _ as usize
        },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DecryptUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DecryptFinal as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DecryptFinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DigestInit as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DigestInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Digest as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Digest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DigestUpdate as *const _ as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DigestUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DigestKey as *const _ as usize },
        162usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DigestKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DigestFinal as *const _ as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DigestFinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SignInit as *const _ as usize },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SignInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Sign as *const _ as usize },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SignUpdate as *const _ as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SignUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SignFinal as *const _ as usize },
        182usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SignFinal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SignRecoverInit as *const _ as usize
        },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SignRecoverInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SignRecover as *const _ as usize },
        190usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SignRecover)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_VerifyInit as *const _ as usize },
        194usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_VerifyInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_Verify as *const _ as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_Verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_VerifyUpdate as *const _ as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_VerifyUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_VerifyFinal as *const _ as usize },
        206usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_VerifyFinal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_VerifyRecoverInit as *const _ as usize
        },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_VerifyRecoverInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_VerifyRecover as *const _ as usize
        },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_VerifyRecover)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DigestEncryptUpdate as *const _ as usize
        },
        218usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DigestEncryptUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DecryptDigestUpdate as *const _ as usize
        },
        222usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DecryptDigestUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SignEncryptUpdate as *const _ as usize
        },
        226usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SignEncryptUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DecryptVerifyUpdate as *const _ as usize
        },
        230usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DecryptVerifyUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GenerateKey as *const _ as usize },
        234usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GenerateKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GenerateKeyPair as *const _ as usize
        },
        238usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GenerateKeyPair)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_WrapKey as *const _ as usize },
        242usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_WrapKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_UnwrapKey as *const _ as usize },
        246usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_UnwrapKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_DeriveKey as *const _ as usize },
        250usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_DeriveKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_SeedRandom as *const _ as usize },
        254usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_SeedRandom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GenerateRandom as *const _ as usize
        },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GenerateRandom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_GetFunctionStatus as *const _ as usize
        },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_GetFunctionStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_CancelFunction as *const _ as usize
        },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_CancelFunction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CK_FUNCTION_LIST>())).C_WaitForSlotEvent as *const _ as usize
        },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(CK_FUNCTION_LIST),
            "::",
            stringify!(C_WaitForSlotEvent)
        )
    );
}
extern crate libloading;
pub struct Pkcs11 {
    __library: ::libloading::Library,
    pub C_GetFunctionList: Result<
        unsafe extern "C" fn(ppFunctionList: CK_FUNCTION_LIST_PTR_PTR) -> CK_RV,
        ::libloading::Error,
    >,
}
impl Pkcs11 {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let C_GetFunctionList = __library.get(b"C_GetFunctionList\0").map(|sym| *sym);
        Ok(Pkcs11 {
            __library,
            C_GetFunctionList,
        })
    }
    pub unsafe fn C_GetFunctionList(&self, ppFunctionList: CK_FUNCTION_LIST_PTR_PTR) -> CK_RV {
        (self
            .C_GetFunctionList
            .as_ref()
            .expect("Expected function, got error."))(ppFunctionList)
    }
}
